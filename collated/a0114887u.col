//@author: a0114887u



	/**
	 * origin: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\database\api\Database.java
	 */

package com.nexus.simplify.database.api;

import java.util.*;
import java.io.IOException;
import java.text.*;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

import org.joda.time.DateTime;

import com.nexus.simplify.database.core.CoreDatabase;
import com.nexus.simplify.database.core.LogicRequest;
import com.nexus.simplify.database.core.Search;
import com.nexus.simplify.database.core.State;
import com.nexus.simplify.database.core.Writer;
import com.nexus.simplify.database.tasktype.DeadlineTask;
import com.nexus.simplify.database.tasktype.GenericTask;
import com.nexus.simplify.database.tasktype.TimedTask;

public class Database implements IDatabase {

	private static final String KEYWORD_DEFAULT = "default";
	private static final String KEYWORD_WORKLOAD = "workload";
	private static final String KEYWORD_DEADLINE = "deadline";
	private static final String KEYWORD_DONE = "done";
	private static final String MSG_FOR_UNDO_ERROR = "Undo is not possible. Please try to add, modify or delete the task instead :)";
	private static final String MSG_START_TIME_AFTER_END_TIME = "Please provide a start time that is earlier than the end time.";
	
	private static final int INDEX_OFFSET_BY_ONE = -1;
	private static final int ZERO = 0;
	
	private static final int PARAMETER_WORKLOAD = 4;
	private static final int PARAMETER_TIME = 2;
	private static final int PARAMETER_NAME = 1;
	
	private static final int TIME_MONTH = 3;
	private static final int TIME_DAY = 2;
	private static final int TIME_WEEKDAY = 1;
	private static final int TIME_HOUR = 0;
	
	//-----------------//
	// Class Variables //
	//-----------------//
	
	private CoreDatabase coreDatabase;
	private Search search = new Search();
	private State state;
	private Writer writer;	
	private LogicRequest logicRequest = new LogicRequest();

	private ObservableList<GenericTask> archivedGenericTl = FXCollections.observableArrayList();
	private ObservableList<DeadlineTask> archivedDeadlineTl = FXCollections.observableArrayList();
	private ObservableList<TimedTask> archivedTimedTl = FXCollections.observableArrayList();
	private ObservableList<GenericTask> observableGenericTl = FXCollections.observableArrayList();
	private ObservableList<DeadlineTask> observableDeadlineTl = FXCollections.observableArrayList();
	private ObservableList<TimedTask> observableTimedTl = FXCollections.observableArrayList();
	private ObservableList<GenericTask> resultantGenericTl = FXCollections.observableArrayList();
	private ObservableList<DeadlineTask> resultantDeadlineTl = FXCollections.observableArrayList();
	private ObservableList<TimedTask> resultantTimedTl = FXCollections.observableArrayList();
	private ObservableList<GenericTask> temporaryGenericTl = FXCollections.observableArrayList();
	private ObservableList<DeadlineTask> temporaryDeadlineTl = FXCollections.observableArrayList();
	private ObservableList<TimedTask> temporaryTimedTl = FXCollections.observableArrayList();

	//-------------//
	// Constructor //
	//-------------//
	
	public Database() throws IOException {
		
		this.coreDatabase = new CoreDatabase();
		state = coreDatabase.getState();
		writer = new Writer(coreDatabase);
		archivedGenericTl = coreDatabase.getArchivedGenericTl();
		archivedDeadlineTl = coreDatabase.getArchivedDeadlineTl();
		archivedTimedTl = coreDatabase.getArchivedTimedTl();
		observableGenericTl = coreDatabase.getObservableGenericTl();
		observableDeadlineTl = coreDatabase.getObservableDeadlineTl();
		observableTimedTl = coreDatabase.getObservableTimedTl();
		
	}
	
	public Database(CoreDatabase coreDatabase) {
		
		this.coreDatabase = coreDatabase;
		state = coreDatabase.getState();
		writer = new Writer(coreDatabase);
		archivedGenericTl = coreDatabase.getArchivedGenericTl();
		archivedDeadlineTl = coreDatabase.getArchivedDeadlineTl();
		archivedTimedTl = coreDatabase.getArchivedTimedTl();
		observableGenericTl = coreDatabase.getObservableGenericTl();
		observableDeadlineTl = coreDatabase.getObservableDeadlineTl();
		observableTimedTl = coreDatabase.getObservableTimedTl();
	
	}

	/**
	 * @return the LogicRequest object of this Database
	 */
	public LogicRequest getLogicRequest() {
		return logicRequest;
	}
	
	public ObservableList<GenericTask> getObservableGenericTL() {
		return observableGenericTl;
	}

	public ObservableList<TimedTask> getObservableTimedTL() {
		return observableTimedTl;
	}

	public ObservableList<DeadlineTask> getObservableDeadlineTL() {
		return observableDeadlineTl;
	}

	public ObservableList<GenericTask> getArchivedGenericTL() {
		return archivedGenericTl;
	}

	public ObservableList<TimedTask> getArchivedTimedTL() {
		return archivedTimedTl;
	}

	public ObservableList<DeadlineTask> getArchivedDeadlineTL() {
		return archivedDeadlineTl;
	}
	
	//---------------//
	// API for Logic //
	//---------------//
	
	/**
	 * Adds a new generic (floating) task to the list of generic tasks.
	 * 
	 * @param name name of task
	 * @param workload amount of effort to be put into the task from a range of 1 - 5
	 * */
	public void addGenericTask(String name, int workload) {

		saveState();
		logicRequest.addGenericTask(name, workload);

		if (workload == ZERO) {
			observableGenericTl.add(new GenericTask(name));
		} else {
			observableGenericTl.add(new GenericTask(name, workload));
		}

		writer.writeToFile(observableGenericTl, observableDeadlineTl, observableTimedTl,
				archivedGenericTl, archivedDeadlineTl, archivedTimedTl);

	}

	/**
	 * Adds a new timed task to the list of timed tasks.
	 * 
	 * @param name name of task
	 * @param startTime time and date when task starts
	 * @param endTime time and date when task ends
	 * @param workload amount of effort to be put into the task from a range of 1 - 5
	 * */
	public void addTimedTask(String name, Date startTime, Date endTime, int workload) throws Exception {

		saveState();
		logicRequest.addTimedTask(name, startTime, endTime, workload);
		
		boolean isStartEqualEnd = startTime.equals(endTime);
		boolean isStartBeforeEnd = startTime.before(endTime);

		if (workload == ZERO) {
			if (isStartEqualEnd) {
				observableDeadlineTl.add(new DeadlineTask(name, startTime));
			} else if (isStartBeforeEnd) {
				observableTimedTl.add(new TimedTask(name, startTime, endTime));
			} else {
				throw new Exception(MSG_START_TIME_AFTER_END_TIME);
			}
		} else {
			if (isStartEqualEnd) {
				observableDeadlineTl.add(new DeadlineTask(name, startTime, workload));
			} else if (isStartBeforeEnd) {
				observableTimedTl.add(new TimedTask(name, startTime, endTime, workload));
			} else {
				throw new Exception(MSG_START_TIME_AFTER_END_TIME);
			}
		}

		writer.writeToFile(observableGenericTl, observableDeadlineTl, observableTimedTl,
				archivedGenericTl, archivedDeadlineTl, archivedTimedTl);

	}

	/**
	 * Adds a new deadline-based task to the list of deadline-based tasks.
	 * 
	 * @param name name of task
	 * @param deadline time and date when task ends
	 * @param workload amount of effort to be put into the task from a range of 1 - 5
	 * */
	public void addDeadlineTask(String name, Date deadline, int workload) {

		saveState();
		logicRequest.addDeadlineTask(name, deadline, workload);

		if (workload == ZERO) {
			observableDeadlineTl.add(new DeadlineTask(name, deadline));
		} else {
			observableDeadlineTl.add(new DeadlineTask(name, deadline, workload));
		}

		writer.writeToFile(observableGenericTl, observableDeadlineTl, observableTimedTl,
				archivedGenericTl, archivedDeadlineTl, archivedTimedTl);
	}

	/**
	 * Deletes a task from the table based on its index being displayed on the billboard.
	 * 
	 * @param index index of task with respect to the billboard
	 * */
	public void deleteTaskByIndex(int index) {

		saveState();
		logicRequest.deleteTaskByIndex(index);

		assert index > ZERO;
		assert index < this.totalSizeOfAllLists();

		int deadlineTLSize = observableDeadlineTl.size();
		int timedTLSize = observableTimedTl.size();

		if (index <= deadlineTLSize) {
			observableDeadlineTl.remove(index + INDEX_OFFSET_BY_ONE);
		} else if (index - deadlineTLSize <= timedTLSize) {
			index = index - deadlineTLSize;
			observableTimedTl.remove(index + INDEX_OFFSET_BY_ONE);
		} else {
			index = index - deadlineTLSize - timedTLSize;
			observableGenericTl.remove(index + INDEX_OFFSET_BY_ONE);
		}

		writer.writeToFile(observableGenericTl, observableDeadlineTl, observableTimedTl,
				archivedGenericTl, archivedDeadlineTl, archivedTimedTl);

	}

	/**
	 * Clears all content from all observable and archived lists.
	 */
	public void clearContent() {

		saveState();
		logicRequest.clearContent();

		observableGenericTl.clear();
		observableTimedTl.clear();
		observableDeadlineTl.clear();
		archivedGenericTl.clear();
		archivedTimedTl.clear();
		archivedDeadlineTl.clear();

		writer.writeToFile(observableGenericTl, observableDeadlineTl, observableTimedTl,
				archivedGenericTl, archivedDeadlineTl, archivedTimedTl);

	}

	/**
	 * Undo the previous command that the user has called.
	 * 
	 * @throws exception if there is no saved state
	 * */
	public void undoTask() throws Exception {
		if (!state.isEmpty()) {
			setObservableTL(state.getFixedGenericState(), state.getFixedDeadlineState(), state.getFixedTimedState());
			setArchivedTL(state.getFixedArchivedGenericState(), state.getFixedArchivedDeadlineState(),
					state.getFixedArchivedTimedState());

			writer.writeToFile(observableGenericTl, observableDeadlineTl, observableTimedTl,
					archivedGenericTl, archivedDeadlineTl, archivedTimedTl);
		} else {
			throw new Exception(MSG_FOR_UNDO_ERROR);
		}
	}

	/**
	 * Sets the observable task lists back to the active/default after performing
	 * search or display done method.
	 * 
	 * */
	public void retrieveActiveTasklists() {
		setObservableTL(temporaryGenericTl, temporaryDeadlineTl, temporaryTimedTl);
	}

	/**
	 * Searchs using user-defined terms for relevant tasks in task lists.
	 * 
	 * @param parameter string array that contain terms to search for
	 * @param searchForTimeUnit boolean array that indicates time unit to search for
	 * @throws parse exception if error occurs when parsing date
	 * */
	public void searchDatabase(String[] parameter, boolean[] searchForTimeUnit) throws java.text.ParseException {

		setTemporaryTL(observableGenericTl, observableDeadlineTl, observableTimedTl);
		resultantGenericTl.clear();
		resultantDeadlineTl.clear();
		resultantTimedTl.clear();

		if (parameter[PARAMETER_NAME] != null) {
			searchInName(parameter[PARAMETER_NAME]);
		} else if (parameter[PARAMETER_TIME] != null) {
			searchForTime(parameter[PARAMETER_TIME], searchForTimeUnit);
		} else {
			searchForWorkload(Integer.valueOf(parameter[PARAMETER_WORKLOAD]));
		}

	}

	/**
	 * Toggles the sorting order of the task lists by a keyword.
	 * 
	 * @param keyword toggles the sorting order of the task lists
	 * */
	public void toggleDisplay(String keyword) {

		if (keyword.equals(KEYWORD_DONE)) {
			setTemporaryTL(observableGenericTl, observableDeadlineTl, observableTimedTl);
			setObservableTL(archivedGenericTl, archivedDeadlineTl, archivedTimedTl);
		} else {
			setObservableTL(temporaryGenericTl, temporaryDeadlineTl, temporaryTimedTl);
			if (keyword.equals(KEYWORD_DEADLINE)) {
				Collections.sort(observableTimedTl, taskStartTimeComparator);
				Collections.sort(observableDeadlineTl, taskDeadlineComparator);
			} else if (keyword.equals(KEYWORD_WORKLOAD)) {
				Collections.sort(observableGenericTl, taskWorkloadComparator);
				Collections.sort(observableTimedTl, taskWorkloadComparator);
				Collections.sort(observableDeadlineTl, taskWorkloadComparator);
			} else if (keyword.equals(KEYWORD_DEFAULT)){
				Collections.sort(observableGenericTl, taskIdComparator);
				Collections.sort(observableTimedTl, taskIdComparator);
				Collections.sort(observableDeadlineTl, taskIdComparator);
			} else {
				// no sorting of list is performed
			}
		}

	}

	/**
	 * Modifies the name value of a task.
	 * 
	 * @param index index of task with respect to the billboard
	 * @param newName new name to be written to the task
	 * */
	public void modifyName(int index, String newName) {

		saveState();
		logicRequest.modifyName(index, newName);

		assert index > ZERO;
		assert index < this.totalSizeOfAllLists();

		int deadlineTLSize = observableDeadlineTl.size();
		int timedTLSize = observableTimedTl.size();

		if (index <= deadlineTLSize) {
			observableDeadlineTl.get(index + INDEX_OFFSET_BY_ONE).setName(newName);
		} else if (index - deadlineTLSize <= timedTLSize) {
			index = index - deadlineTLSize;
			observableTimedTl.get(index + INDEX_OFFSET_BY_ONE).setName(newName);
		} else {
			index = index - deadlineTLSize - timedTLSize;
			observableGenericTl.get(index + INDEX_OFFSET_BY_ONE).setName(newName);
		}

		writer.writeToFile(observableGenericTl, observableDeadlineTl, observableTimedTl,
				archivedGenericTl, archivedDeadlineTl, archivedTimedTl);

	}

	/**
	 * Modifies the workload value of a task.
	 * 
	 * @param index index of task with respect to the billboard
	 * @param newWorkloadValue new value of workload to be written to the task
	 * @throws Exception if workload is not in range of 1 - 5 inclusive.
	 * */
	public void modifyWorkload(int index, int newWorkloadValue) {

		saveState();
		logicRequest.modifyWorkload(index, newWorkloadValue);

		assert index > ZERO;
		assert index < this.totalSizeOfAllLists();

		int deadlineTLSize = observableDeadlineTl.size();
		int timedTLSize = observableTimedTl.size();

		if (index <= deadlineTLSize) {
			observableDeadlineTl.get(index + INDEX_OFFSET_BY_ONE).setWorkload(newWorkloadValue);
		} else if (index - deadlineTLSize <= timedTLSize) {
			index = index - deadlineTLSize;
			observableTimedTl.get(index + INDEX_OFFSET_BY_ONE).setWorkload(newWorkloadValue);
		} else {
			index = index - deadlineTLSize - timedTLSize;
			observableGenericTl.get(index + INDEX_OFFSET_BY_ONE).setWorkload(newWorkloadValue);
		}

		writer.writeToFile(observableGenericTl, observableDeadlineTl, observableTimedTl,
				archivedGenericTl, archivedDeadlineTl, archivedTimedTl);
	}

	/**
	 * Modifies the start and/or time of a task.
	 * Convert deadline tasks to timed tasks when start or end time is introduced.
	 * Convert timed tasks to deadline tasks when start or end time is removed.
	 * Convert generic task to deadline or timed task when start and/or end time is introduced.
	 * 
	 * @param index index of task with respect to the billboard
	 * @param newStartTime new value of start time to be written to the task
	 * @param newEndTime new value of end time to be written to the task
	 * @throws Exception when start time is later than end time
	 * */
	public void modifyStartEnd(int index, Date newStartTime, Date newEndTime) throws Exception {

		saveState();
		// logicRequest.modifyStartTime(index, newStartTime);

		assert index > ZERO;
		assert index < this.totalSizeOfAllLists();

		DateTime startTime = new DateTime(newStartTime);
		DateTime endTime = new DateTime(newEndTime);
		int deadlineTLSize = observableDeadlineTl.size();
		int timedTLSize = observableTimedTl.size();
		boolean isStartEqualEnd = newStartTime.equals(newEndTime);
		boolean isStartBeforeEnd = newStartTime.before(newEndTime);

		if (index <= deadlineTLSize) {

			if (isStartEqualEnd) {
				observableDeadlineTl.get(index + INDEX_OFFSET_BY_ONE).setDeadline(newStartTime);
			} else if (isStartBeforeEnd){
				DeadlineTask task = observableDeadlineTl.get(index + INDEX_OFFSET_BY_ONE);
				observableTimedTl.add(new TimedTask(task.getNameAsStringProperty(), startTime, endTime,
						task.getWorkloadAsIntegerProperty(), task.getIDAsStringProperty()));
				observableDeadlineTl.remove(index + INDEX_OFFSET_BY_ONE);
			} else {
				throw new Exception(MSG_START_TIME_AFTER_END_TIME);
			}

		} else if (index - deadlineTLSize <= timedTLSize) {

			index = index - deadlineTLSize;
			TimedTask task = observableTimedTl.get(index + INDEX_OFFSET_BY_ONE);
			if (isStartEqualEnd) {
				observableDeadlineTl.add(new DeadlineTask(task.getNameAsStringProperty(), startTime,
						task.getWorkloadAsIntegerProperty(), task.getIDAsStringProperty()));
				observableTimedTl.remove(index + INDEX_OFFSET_BY_ONE);
			} else if (isStartBeforeEnd) {
				task.setStartTime(newStartTime);
				task.setEndTime(newEndTime);
			} else {
				throw new Exception(MSG_START_TIME_AFTER_END_TIME);
			}

		} else {

			index = index - deadlineTLSize - timedTLSize;
			GenericTask task = observableGenericTl.get(index + INDEX_OFFSET_BY_ONE);
			if (isStartEqualEnd) {
				observableDeadlineTl.add(new DeadlineTask(task.getNameAsStringProperty(), newStartTime,
						task.getWorkloadAsIntegerProperty(), task.getIDAsStringProperty()));
				observableGenericTl.remove(index + INDEX_OFFSET_BY_ONE);
			} else if (isStartBeforeEnd) {
				observableTimedTl.add(new TimedTask(task.getNameAsStringProperty(), startTime, endTime,
						task.getWorkloadAsIntegerProperty(), task.getIDAsStringProperty()));
				observableGenericTl.remove(index + INDEX_OFFSET_BY_ONE);
			} else {
				throw new Exception(MSG_START_TIME_AFTER_END_TIME);
			}

		}

		writer.writeToFile(observableGenericTl, observableDeadlineTl, observableTimedTl,
				archivedGenericTl, archivedDeadlineTl, archivedTimedTl);

	}

	/**
	 * Marks the task at index as done, remove from observable task lists
	 * and add to the archived task lists.
	 * 
	 * @param indexToMarkDone index of task to be marked as done
	 * */
	public void markTaskDone(int indexToMarkDone) {

		saveState();
		logicRequest.markTaskDone(indexToMarkDone);

		assert indexToMarkDone > ZERO;
		assert indexToMarkDone < this.totalSizeOfAllLists();

		int deadlineTLSize = observableDeadlineTl.size();
		int timedTLSize = observableTimedTl.size();

		if (indexToMarkDone <= deadlineTLSize) {
			archivedDeadlineTl.add(observableDeadlineTl.get(indexToMarkDone + INDEX_OFFSET_BY_ONE));
			observableDeadlineTl.remove(indexToMarkDone + INDEX_OFFSET_BY_ONE);
		} else if (indexToMarkDone - deadlineTLSize <= timedTLSize) {
			indexToMarkDone = indexToMarkDone - deadlineTLSize;
			archivedTimedTl.add(observableTimedTl.get(indexToMarkDone + INDEX_OFFSET_BY_ONE));
			observableTimedTl.remove(indexToMarkDone + INDEX_OFFSET_BY_ONE);
		} else {
			indexToMarkDone = indexToMarkDone - deadlineTLSize - timedTLSize;
			archivedGenericTl.add(observableGenericTl.get(indexToMarkDone + INDEX_OFFSET_BY_ONE));
			observableGenericTl.remove(indexToMarkDone + INDEX_OFFSET_BY_ONE);
		}

		writer.writeToFile(observableGenericTl, observableDeadlineTl, observableTimedTl,
				archivedGenericTl, archivedDeadlineTl, archivedTimedTl);
	}

	/**
	 * Modifies the file location to that defined by the user. 
	 * */
	public void modifyFileLocation(String newFileLocation) throws IOException {
		coreDatabase.setDataFileLocation(newFileLocation);
	}
	
	/**
	 * Returns the file location of the external storage.
	 * */
	public String getDataFileLocation() {
		return coreDatabase.getDataFileLocation();
	}

	/**
	 * Searches for the given time unit in dates of tasks and display all tasks that contain
	 * the time unit (except for Generic Task).
	 * 
	 * @param search search instance
	 * @param dateInString date with time unit to search for included
	 * @param searchForTimeUnit boolean array with time unit to search for indicated with true
	 * */
	private void searchForTime(String dateInString, boolean[] searchForTimeUnit)
			throws java.text.ParseException {

		String pattern = "E MMM dd HH:mm:ss zzz yyy";
		SimpleDateFormat format = new SimpleDateFormat(pattern);
		DateTime date = new DateTime(format.parse(dateInString));
		int searchFor = ZERO;

		for(boolean boo: searchForTimeUnit) {

			if (boo == true) {

				if (searchFor == TIME_HOUR) {
					search.searchDeadlineTlByHour(date.getHourOfDay(), observableDeadlineTl,
							resultantDeadlineTl);
					search.searchTimedTlByHour(date.getHourOfDay(), observableTimedTl, resultantTimedTl);
				} else if (searchFor == TIME_WEEKDAY) {
					search.searchDeadlineTlByWeekday(date.getDayOfWeek(), observableDeadlineTl,
							resultantDeadlineTl);
					search.searchTimedTlByWeekday(date.getDayOfWeek(), observableTimedTl, resultantTimedTl);
				} else if (searchFor == TIME_DAY) {
					search.searchDeadlineTlByDay(date.getDayOfMonth(), observableDeadlineTl,
							resultantDeadlineTl);
					search.searchTimedTlByDay(date.getDayOfMonth(), observableTimedTl, resultantTimedTl);
				} else if (searchFor == TIME_MONTH) {
					search.searchDeadlineTlByMonth(date.getMonthOfYear(), observableDeadlineTl,
							resultantDeadlineTl);
					search.searchTimedTlByMonth(date.getMonthOfYear(), observableTimedTl, resultantTimedTl);
				} else {
					search.searchDeadlineTlByYear(date.getYear(), observableDeadlineTl, resultantDeadlineTl);
					search.searchTimedTlByYear(date.getYear(), observableTimedTl, resultantTimedTl);
				}

			}

			searchFor++;

		}

		setTemporaryTL(observableGenericTl, observableDeadlineTl, observableTimedTl);
		setObservableTL(resultantGenericTl, resultantDeadlineTl, resultantTimedTl);

	}

	/**
	 * Searches for the given term in the names of tasks and display all tasks that contains
	 * the term.
	 * 
	 * @param search search instance
	 * @param term term to search for in names of tasks
	 * */
	private void searchInName(String term){

		search.searchDeadlineTlByName(term, observableDeadlineTl, resultantDeadlineTl);
		search.searchGenericTlByName(term, observableGenericTl, resultantGenericTl);
		search.searchTimedTlByName(term, observableTimedTl, resultantTimedTl);

		setTemporaryTL(observableGenericTl, observableDeadlineTl, observableTimedTl);
		setObservableTL(resultantGenericTl, resultantDeadlineTl, resultantTimedTl);

	}

	/**
	 * Searches for the given workload of tasks and display all tasks that contains the
	 * workload.
	 * 
	 * @param search search instance
	 * @param workload workload to search for
	 * */
	private void searchForWorkload(int workload){

		search.searchDeadlineTlByWorkload(workload, observableDeadlineTl, resultantDeadlineTl);
		search.searchGenericTlByWorkload(workload, observableGenericTl, resultantGenericTl);
		search.searchTimedTlByWorkload(workload, observableTimedTl, resultantTimedTl);

		setTemporaryTL(observableGenericTl, observableDeadlineTl, observableTimedTl);
		setObservableTL(resultantGenericTl, resultantDeadlineTl, resultantTimedTl);

	}

	/**
	 * Returns the total size of all three task lists.
	 * 
	 * @return total size of all three task lists
	 * */
	private int totalSizeOfAllLists() {
		return observableGenericTl.size() + observableDeadlineTl.size() + observableTimedTl.size();
	}

	/**
	 * Saves the state of all observable and archived lists to facilitate undo method.
	 * */
	private void saveState() {
		state.saveState(observableGenericTl, observableDeadlineTl, observableTimedTl,
				archivedGenericTl, archivedDeadlineTl, archivedTimedTl);
	}
	
	//------------------//
	// Variable Setters //
	//------------------//

	private void setObservableTL(ObservableList<GenericTask> genericTL,
									ObservableList<DeadlineTask> deadlineTL,
									ObservableList<TimedTask> timedTL) {
		
		observableDeadlineTl.setAll(deadlineTL);
		observableTimedTl.setAll(timedTL);
		observableGenericTl.setAll(genericTL);
	}

	private void setTemporaryTL(ObservableList<GenericTask> genericTL,
								ObservableList<DeadlineTask> deadlineTL,
								ObservableList<TimedTask> timedTL) {
		
		temporaryDeadlineTl.setAll(deadlineTL);
		temporaryTimedTl.setAll(timedTL);
		temporaryGenericTl.setAll(genericTL);
	}

	private void setArchivedTL(ObservableList<GenericTask>genericTL,
								ObservableList<DeadlineTask> deadlineTL,
								ObservableList<TimedTask> timedTL) {
		
		archivedDeadlineTl.setAll(deadlineTL);
		archivedTimedTl.setAll(timedTL);
		archivedGenericTl.setAll(genericTL);
	}

	//-------------//
	// Comparators //
	//-------------//

	private Comparator<GenericTask> taskWorkloadComparator = new Comparator<GenericTask>() {
		public int compare(GenericTask t1, GenericTask t2) {
			String t1Workload = Integer.toString(t1.getWorkload());
			String t2Workload = Integer.toString(t2.getWorkload());
			return t1Workload.compareTo(t2Workload);
		}
	};

	private Comparator<GenericTask> taskIdComparator = new Comparator<GenericTask>() {
		public int compare(GenericTask t1, GenericTask t2) {
			DateTime t1Id = t1.getIDAsDateTime();
			DateTime t2Id = t2.getIDAsDateTime();
			if(t1Id.isBefore(t2Id)) {
				return -1;
			} else {
				return 1;
			}
		}
	};

	private Comparator<DeadlineTask> taskDeadlineComparator = new Comparator<DeadlineTask>() {
		public int compare(DeadlineTask t1, DeadlineTask t2) {
			DateTime t1Deadline = t1.getDeadline();
			DateTime t2Deadline = t2.getDeadline();
			if(t1Deadline.isBefore(t2Deadline)) {
				return -1;
			} else {
				return 1;
			}
		}
	};

	private Comparator<TimedTask> taskStartTimeComparator = new Comparator<TimedTask>() {
		public int compare(TimedTask t1, TimedTask t2) {
			DateTime t1StartTime = t1.getStartTimeAsDateTime();
			DateTime t2StartTime = t2.getStartTimeAsDateTime();
			if(t1StartTime.isBefore(t2StartTime)) {
				return -1;
			} else {
				return 1;
			}
		}
	};
}

	// End of segment: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\database\api\Database.java





	/**
	 * origin: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\database\api\IDatabase.java
	 */

package com.nexus.simplify.database.api;

import java.io.IOException;
import java.util.Date;

public interface IDatabase {
	
	void addGenericTask(String name, int workload);
	void addDeadlineTask(String name, Date deadline, int workload);
	void addTimedTask(String name, Date startTime, Date endTime, int workload) throws Exception;
	void deleteTaskByIndex(int index);
	void clearContent();
	void undoTask() throws Exception;
	void retrieveActiveTasklists();
	void searchDatabase(String[] parameter, boolean[] searchForTimeUnit) throws java.text.ParseException;
	void toggleDisplay(String keyword);
	void modifyName(int index, String newName);
	void modifyWorkload(int index, int newWorkloadValue);
	void modifyStartEnd(int index, Date newStartTime, Date newEndTime) throws Exception;
	void markTaskDone(int indexToMarkDone);
	void modifyFileLocation(String newFileLocation) throws IOException;
	String getDataFileLocation();
	
}

	// End of segment: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\database\api\IDatabase.java





	/**
	 * origin: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\database\core\CoreDatabase.java
	 */


package com.nexus.simplify.database.core;

import java.io.*;
import java.net.URL;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;

import org.json.simple.JSONArray;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nexus.simplify.database.core.Reader;
import com.nexus.simplify.database.tasktype.DeadlineTask;
import com.nexus.simplify.database.tasktype.GenericTask;
import com.nexus.simplify.database.tasktype.TimedTask;

public class CoreDatabase {


	private static final String DEFAULT_FILE_NAME = "Simplify-Data.json";
	private static final String KEY_FILE_LOCATION = "File location";
	
	private URL url = CoreDatabase.class.getProtectionDomain().getCodeSource().getLocation();
	private String defaultFileLocation = url.getPath();

	private Preferences preference;
	private State state;
	private Reader reader;
	private String dataFileLocation;
	
	private ObservableList<GenericTask> archivedGenericTl = FXCollections.observableArrayList();
	private ObservableList<DeadlineTask> archivedDeadlineTl = FXCollections.observableArrayList();
	private ObservableList<TimedTask> archivedTimedTl = FXCollections.observableArrayList();
	private ObservableList<GenericTask> observableGenericTl = FXCollections.observableArrayList();
	private ObservableList<DeadlineTask> observableDeadlineTl = FXCollections.observableArrayList();
	private ObservableList<TimedTask> observableTimedTl = FXCollections.observableArrayList();

	private Logger LOGGER = LoggerFactory.getLogger(CoreDatabase.class.getName());
	
	//-------------//
	// Constructor //
	//-------------//

	/**
	 * @param fileName name of input file to be opened
	 * @throws IOException for an interrupted IO operation.
	 * s
	 * */
	public CoreDatabase() throws IOException {
		
		initDatabase();
		reader = new Reader(this);
		JSONArray jsonTaskArray = reader.retrieveDataFromDataFile(getDataFilePath());
		reader.populateTaskLists(jsonTaskArray);
		state = new State();
		
	}

	//----------------//
	// Initialization //
	//----------------//

	public void initDatabase() throws IOException {
		
		preference = Preferences.userRoot().node(this.getClass().getName());
		try {
			preference.clear();
		} catch (BackingStoreException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		final String NO_SAVED_FILEPATH_FOUND = "";
		String fileLocationPath = preference.get(KEY_FILE_LOCATION, NO_SAVED_FILEPATH_FOUND);
		
		if (fileLocationPath.equals(NO_SAVED_FILEPATH_FOUND)) {
			defaultFileLocation = defaultFileLocation.replace("Simplify.jar", "");
			preference.put(KEY_FILE_LOCATION, defaultFileLocation);
			dataFileLocation = defaultFileLocation;
			LOGGER.info("Default settings for file location will be loaded.");
		} else {
			dataFileLocation = fileLocationPath;
			LOGGER.info("Saved settings for file location will be loaded.");
		}
		
	}

	//---------------------//
	// Attribute Accessors //
	//---------------------//

	public ObservableList<GenericTask> getObservableGenericTl() {
		return this.observableGenericTl;
	}

	public ObservableList<TimedTask> getObservableTimedTl() {
		return this.observableTimedTl;
	}

	public ObservableList<DeadlineTask> getObservableDeadlineTl() {
		return this.observableDeadlineTl;
	}

	public ObservableList<GenericTask> getArchivedGenericTl() {
		return this.archivedGenericTl;
	}

	public ObservableList<TimedTask> getArchivedTimedTl() {
		return this.archivedTimedTl;
	}

	public ObservableList<DeadlineTask> getArchivedDeadlineTl() {
		return this.archivedDeadlineTl;
	}
	
	public State getState() {
		return this.state;
	}
	
	public Reader getReader() {
		return this.reader;
	}

	/**
	 * @return the relative file path.
	 * */
	public String getDataFilePath() {
		return this.dataFileLocation + DEFAULT_FILE_NAME;
	}

	/**
	 * @return the location (directory) of the file.
	 * */
	public String getDataFileLocation() {
		return this.dataFileLocation;
	}

	//--------------------//
	// Attribute Mutators //
	//--------------------//

	public void setObservableGenericTl(ObservableList<GenericTask> generic) {
		this.observableGenericTl = generic;
	}

	public void setObservableTimedTl(ObservableList<TimedTask> timed) {
		this.observableTimedTl = timed;
	}

	public void setObservableDeadlineTl(ObservableList<DeadlineTask> deadline) {
		this.observableDeadlineTl = deadline;
	}

	public void setArchivedGenericTl(ObservableList<GenericTask> generic) {
		this.archivedGenericTl = generic;
	}

	public void setArchivedTimedTl(ObservableList<TimedTask> timed) {
		this.archivedTimedTl = timed;
	}

	public void setArchivedDeadlineTl(ObservableList<DeadlineTask> deadline) {
		this.archivedDeadlineTl = deadline;
	}

	public void setDataFileLocation(String newFileLocation) throws IOException {
		
		preference.put(KEY_FILE_LOCATION, newFileLocation);
		dataFileLocation = newFileLocation;
		File file;
		Writer writer = new Writer();
		
		if (isLastCharBackSlash(dataFileLocation)) {
			file = new File(dataFileLocation + DEFAULT_FILE_NAME);
		} else {
			file = new File(dataFileLocation + '\\' + DEFAULT_FILE_NAME);
		}
		
		file.getParentFile().mkdirs();
		file.createNewFile();
		writer.writeToFile(observableGenericTl, observableDeadlineTl, observableTimedTl,
				archivedGenericTl, archivedDeadlineTl, archivedTimedTl, file);
		
	}

	private boolean isLastCharBackSlash(String string) {
		
		int lastIndex = string.length() - 1;
		if (string.charAt(lastIndex) == '\'') {
			return true;
		} else {
			return false;
		}
		
	}
}
	// End of segment: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\database\core\CoreDatabase.java





	/**
	 * origin: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\database\core\Search.java
	 */

package com.nexus.simplify.database.core;

import javafx.collections.ObservableList;

import com.nexus.simplify.database.tasktype.DeadlineTask;
import com.nexus.simplify.database.tasktype.GenericTask;
import com.nexus.simplify.database.tasktype.TimedTask;

/**
 * Represents an instance of a search used to search for user-defined terms.
 * */
public class Search {

	final private int HEAD_OF_RESULT_LIST = 0;
	//-------------//
	// Constructor //
	//-------------//
	
	public Search() {}
	
	//---------//
	// Methods //
	//---------//
	
	public ObservableList<GenericTask> searchGenericTlByName(String term,
																ObservableList<GenericTask> genericTl,
																ObservableList<GenericTask> resultantTl) {
		
		assert !genericTl.isEmpty();
	
		for(GenericTask genericTask : genericTl) {
			if (genericTask.getName().contains(term) && !resultantTl.contains(genericTask)) {
				resultantTl.add(genericTask);
			}
		}
		return resultantTl;
	
	}
	
	public ObservableList<GenericTask> searchGenericTlByWorkload(int workload,
																	ObservableList<GenericTask> genericTl,
																	ObservableList<GenericTask> resultantTl) {
		
		assert !genericTl.isEmpty();
		
		for(GenericTask genericTask : genericTl) {
			if (genericTask.getWorkload() == workload && !resultantTl.contains(genericTask)) {
				resultantTl.add(genericTask);
			}
		}
		return resultantTl;
	
	}
	
	public ObservableList<DeadlineTask> searchDeadlineTlByName(String term,
																ObservableList<DeadlineTask> deadlineTl,
																ObservableList<DeadlineTask> resultantTl) {
		
		assert !deadlineTl.isEmpty();
		
		for(DeadlineTask deadlineTask : deadlineTl) {
			if (deadlineTask.getName().contains(term) && !resultantTl.contains(deadlineTask)) {
				resultantTl.add(deadlineTask);
			}
		}
		return resultantTl;
	
	}
	
	public ObservableList<DeadlineTask> searchDeadlineTlByWorkload(int workload,
																	ObservableList<DeadlineTask> deadlineTl,
																	ObservableList<DeadlineTask> resultantTl) {
		
		assert !deadlineTl.isEmpty();
		
		for(DeadlineTask deadlineTask : deadlineTl) {
			if (deadlineTask.getWorkload() == workload && !resultantTl.contains(deadlineTask)) {
				resultantTl.add(deadlineTask);
			}
		}
		
		return resultantTl;
	
	}
	
	public ObservableList<DeadlineTask> searchDeadlineTlByYear(int year,
																ObservableList<DeadlineTask> deadlineTl,
																ObservableList<DeadlineTask> resultantTl) {
		
		assert !deadlineTl.isEmpty();
		
		for(DeadlineTask deadlineTask : deadlineTl) {
			if (deadlineTask.getDeadline().getYear() == year && !resultantTl.contains(deadlineTask)) {
				resultantTl.add(deadlineTask);
			} else if (deadlineTask.getDeadline().getYear() == year && resultantTl.contains(deadlineTask)) {
				resultantTl.remove(deadlineTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, deadlineTask);
			}
		}
		
		return resultantTl;
	
	}
	
	public ObservableList<DeadlineTask> searchDeadlineTlByMonth(int month,
																ObservableList<DeadlineTask> deadlineTl,
																ObservableList<DeadlineTask> resultantTl) {
		
		assert !deadlineTl.isEmpty();
		
		for(DeadlineTask deadlineTask : deadlineTl) {
			if (deadlineTask.getDeadline().getMonthOfYear() == month && !resultantTl.contains(deadlineTask)) {
				resultantTl.add(deadlineTask);
			} else if (deadlineTask.getDeadline().getMonthOfYear() == month && resultantTl.contains(deadlineTask)) {
				resultantTl.remove(deadlineTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, deadlineTask);
			}
		}
		
		return resultantTl;
	
	}

	public ObservableList<DeadlineTask> searchDeadlineTlByDay(int day,
																ObservableList<DeadlineTask> deadlineTl,
																ObservableList<DeadlineTask> resultantTl) {
		
		assert !deadlineTl.isEmpty();
		
		for(DeadlineTask deadlineTask : deadlineTl) {
			if (deadlineTask.getDeadline().getDayOfMonth() == day && !resultantTl.contains(deadlineTask)) {
				resultantTl.add(deadlineTask);
			} else if (deadlineTask.getDeadline().getDayOfMonth() == day && resultantTl.contains(deadlineTask)) {
				resultantTl.remove(deadlineTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, deadlineTask);
			}
		}
		
		return resultantTl;
	
	}
	
	public ObservableList<DeadlineTask> searchDeadlineTlByWeekday(int weekday, 
																	ObservableList<DeadlineTask> deadlineTl,
																	ObservableList<DeadlineTask> resultantTl) {
		
		assert !deadlineTl.isEmpty();
		
		for(DeadlineTask deadlineTask : deadlineTl) {
			if (deadlineTask.getDeadline().getDayOfWeek() == weekday && !resultantTl.contains(deadlineTask)) {
				resultantTl.add(deadlineTask);
			} else if (deadlineTask.getDeadline().getDayOfWeek() == weekday && resultantTl.contains(deadlineTask)) {
				resultantTl.remove(deadlineTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, deadlineTask);
			}
		}
		
		return resultantTl;
	
	}
	
	public ObservableList<DeadlineTask> searchDeadlineTlByHour(int hour,
																ObservableList<DeadlineTask> deadlineTl,
																ObservableList<DeadlineTask> resultantTl) {
		
		assert !deadlineTl.isEmpty();
		
		for(DeadlineTask deadlineTask : deadlineTl) {
			if (deadlineTask.getDeadline().getHourOfDay() == hour && !resultantTl.contains(deadlineTask)) {
				resultantTl.add(deadlineTask);
			} else if (deadlineTask.getDeadline().getHourOfDay() == hour && resultantTl.contains(deadlineTask)) {
				resultantTl.remove(deadlineTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, deadlineTask);
			}
		}
		
		return resultantTl;
	
	}
	
	public ObservableList<TimedTask> searchTimedTlByName(String term,
															ObservableList<TimedTask> timedTl,
															ObservableList<TimedTask> resultantTl) {
		
		assert !timedTl.isEmpty();
		
		for(TimedTask timedTask : timedTl) {
			if (timedTask.getName().contains(term) && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			}
		}
		return resultantTl;
	
	}
	
	public ObservableList<TimedTask> searchTimedTlByWorkload(int workload,
																ObservableList<TimedTask> timedTl,
																ObservableList<TimedTask> resultantTl) {
	
		assert !timedTl.isEmpty();
		
		for(TimedTask timedTask : timedTl) {
			if (timedTask.getWorkload() == workload && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			}
		}
		
		return resultantTl;
	
	}
	
	public ObservableList<TimedTask> searchTimedTlByYear(int year,
															ObservableList<TimedTask> timedTl,
															ObservableList<TimedTask> resultantTl) {
	
		assert !timedTl.isEmpty();
		
		for(TimedTask timedTask : timedTl) {
			if (timedTask.getStartTimeAsDateTime().getYear() == year && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			} else if (timedTask.getStartTimeAsDateTime().getYear() == year && resultantTl.contains(timedTask)) {
				resultantTl.remove(timedTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, timedTask);
			} else if (timedTask.getEndTimeAsDateTime().getYear() == year && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			} else if (timedTask.getEndTimeAsDateTime().getYear() == year && resultantTl.contains(timedTask)) {
				resultantTl.remove(timedTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, timedTask);
			}
		}
		
		return resultantTl;
	}
	
	public ObservableList<TimedTask> searchTimedTlByMonth(int month,
															ObservableList<TimedTask> timedTl,
															ObservableList<TimedTask> resultantTl) {
		
		assert !timedTl.isEmpty();
		
		for(TimedTask timedTask : timedTl) {
			if (timedTask.getStartTimeAsDateTime().getMonthOfYear() == month && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			} else if (timedTask.getStartTimeAsDateTime().getMonthOfYear() == month && resultantTl.contains(timedTask)) {
				resultantTl.remove(timedTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, timedTask);
			} else if (timedTask.getEndTimeAsDateTime().getMonthOfYear() == month && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			} else if (timedTask.getEndTimeAsDateTime().getMonthOfYear() == month && resultantTl.contains(timedTask)) {
				resultantTl.remove(timedTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, timedTask);
			}
		}
		
		return resultantTl;
	
	}
	
	public ObservableList<TimedTask> searchTimedTlByDay(int day,
														ObservableList<TimedTask> timedTl,
														ObservableList<TimedTask> resultantTl) {
		
		assert !timedTl.isEmpty();
		
		for(TimedTask timedTask : timedTl) {
			if (timedTask.getStartTimeAsDateTime().getDayOfMonth() == day && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			}  else if (timedTask.getStartTimeAsDateTime().getDayOfMonth() == day && resultantTl.contains(timedTask)) {
				resultantTl.remove(timedTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, timedTask);
			} else if (timedTask.getEndTimeAsDateTime().getDayOfMonth() == day && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			}  else if (timedTask.getEndTimeAsDateTime().getDayOfMonth() == day && resultantTl.contains(timedTask)) {
				resultantTl.remove(timedTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, timedTask);
			}
		}
		
		return resultantTl;
	
	}
	
	public ObservableList<TimedTask> searchTimedTlByWeekday(int weekday,
															ObservableList<TimedTask> timedTl,
															ObservableList<TimedTask> resultantTl) {
		
		assert !timedTl.isEmpty();
		
		for(TimedTask timedTask : timedTl) {
			if (timedTask.getStartTimeAsDateTime().getDayOfWeek() == weekday && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			} else if (timedTask.getStartTimeAsDateTime().getDayOfWeek() == weekday && resultantTl.contains(timedTask)) {
				resultantTl.remove(timedTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, timedTask);
			} else if (timedTask.getEndTimeAsDateTime().getDayOfWeek() == weekday && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			} else if (timedTask.getEndTimeAsDateTime().getDayOfWeek() == weekday && resultantTl.contains(timedTask)) {
				resultantTl.remove(timedTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, timedTask);
			} 
		}
		
		return resultantTl;
	
	}
	
	public ObservableList<TimedTask> searchTimedTlByHour(int hour,
															ObservableList<TimedTask> timedTl,
															ObservableList<TimedTask> resultantTl) {
		
		assert !timedTl.isEmpty();
		
		for(TimedTask timedTask : timedTl) {
			if (timedTask.getStartTimeAsDateTime().getHourOfDay() == hour && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			} else if (timedTask.getStartTimeAsDateTime().getHourOfDay() == hour && resultantTl.contains(timedTask)) {
				resultantTl.remove(timedTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, timedTask);
			} else if (timedTask.getEndTimeAsDateTime().getHourOfDay() == hour && !resultantTl.contains(timedTask)) {
				resultantTl.add(timedTask);
			} else if (timedTask.getEndTimeAsDateTime().getHourOfDay() == hour && resultantTl.contains(timedTask)) {
				resultantTl.remove(timedTask);
				resultantTl.add(HEAD_OF_RESULT_LIST, timedTask);
			}
		}
		
		return resultantTl;
	
	}
}
	// End of segment: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\database\core\Search.java





	/**
	 * origin: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\database\tasktype\TimedTask.java
	 */

package com.nexus.simplify.database.tasktype;

import java.util.Date;

import javafx.beans.property.*;

import org.joda.time.DateTime;
import org.joda.time.format.*;

/**
 * Represents an instance of task tagged with start and end time.
 */
public class TimedTask extends GenericTask {
	
	/**
	 * All dates will be shaped according to this format. 
	 * <DAY> <MONTH> <YEAR> <HOUR>:<MINUTE>
	 * */
	private static final String JAVA_DATE_FORMAT = "dd MMM yyyy HH:mm";
	private DateTimeFormatter format = DateTimeFormat.forPattern(JAVA_DATE_FORMAT);
	
	//-----------------//
	// Class Attribute //
	//-----------------//
	
	// End of segment: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\database\tasktype\TimedTask.java





	/**
	 * origin: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\test\database\DatabaseTest.java
	 */

	@SuppressWarnings("deprecation")
	@Test
	public void testAddDeadlineTaskToList() {
		// Test case 1a: adding a Deadline task with workload
		DeadlineTask expectedDeadlineTaskCase1 = new DeadlineTask("Deadline Task Test 1a", new Date(115, 6, 1), 5);
		database.addDeadlineTask("Deadline Task Test 1a", new Date(115, 6, 1), 5);
		DeadlineTask resultantDeadlineTaskCase1 = coreDatabase.getObservableDeadlineTl().get(0);
		assertEquals(expectedDeadlineTaskCase1.getName(), resultantDeadlineTaskCase1.getName());
		assertEquals(expectedDeadlineTaskCase1.getDeadline(), resultantDeadlineTaskCase1.getDeadline());
		assertEquals(expectedDeadlineTaskCase1.getWorkload(), resultantDeadlineTaskCase1.getWorkload());
		
		database.clearContent();
		
		// Test case 1b: adding a Deadline task with no workload
		DeadlineTask expectedDeadlineTaskCase2 = new DeadlineTask("Deadline Task Test 1b", new Date("29 Mar 2015 16:00"), 1);
		database.addDeadlineTask("Deadline Task Test 1b", new Date("29 Mar 2015 16:00"), 0);
		DeadlineTask resultantDeadlineTaskCase2 = coreDatabase.getObservableDeadlineTl().get(0);
		assertEquals(expectedDeadlineTaskCase2.getName(), resultantDeadlineTaskCase2.getName());
		assertEquals(expectedDeadlineTaskCase2.getDeadline(), resultantDeadlineTaskCase2.getDeadline());
		assertEquals(expectedDeadlineTaskCase2.getWorkload(), resultantDeadlineTaskCase2.getWorkload());
	}


	@Test
	public void testDeleteTaskFromList() {
		// add dummy data
		database.addGenericTask("Watch movie", 2);
		database.addGenericTask("Walk the Dog", 5);
		database.addGenericTask("Read book", 3);
		database.addGenericTask("Do laundry", 4);
		database.addGenericTask("Sleep", 1);
		
		database.deleteTaskByIndex(3);
		
		// test for current position task
		GenericTask expectedGenericTaskAtIndexThree = new GenericTask("Do laundry", 4);
		GenericTask currentGenericTaskAtIndexThree = coreDatabase.getObservableGenericTl().get(2);
		assertEquals(expectedGenericTaskAtIndexThree.getName(), currentGenericTaskAtIndexThree.getName());
		assertEquals(expectedGenericTaskAtIndexThree.getWorkload(), currentGenericTaskAtIndexThree.getWorkload());
	}

}

	// End of segment: M:\Documents\GitHub\CS2103T-NEXUS\src\com\nexus\simplify\test\database\DatabaseTest.java





