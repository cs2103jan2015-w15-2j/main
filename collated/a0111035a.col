//@author: a0111035a



	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\database\core\LogicRequest.java
	 */

package com.nexus.simplify.database.core;

import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nexus.simplify.logic.usercommand.OperationType;
import com.nexus.simplify.logic.usercommand.ParameterType;

/**
 * Helper class for testing purposes. Allows to track the method and parameters that
 * Logic calls on Database
 *  
	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\database\core\LogicRequest.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\database\tasktype\DeadlineTask.java
	 */

	/**
	 * Returns an exact copy of the task.
	 * */
	public DeadlineTask getCopy() {
		StringProperty cName = new SimpleStringProperty(getName());
		IntegerProperty cWorkload = new SimpleIntegerProperty(getWorkload());
		StringProperty cID = new SimpleStringProperty(getId());
		DateTime cDeadline = getDeadline();
		DeadlineTask copy = new DeadlineTask(cName, cDeadline, cWorkload, cID);
		return copy;
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\database\tasktype\DeadlineTask.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\api\IParser.java
	 */


package com.nexus.simplify.parser.api;

import com.nexus.simplify.logic.usercommand.UserCommand;

/**
 * Interface class for facade of Parser component.
 * 
	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\api\IParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\api\Parser.java
	 */


package com.nexus.simplify.parser.api;

import java.io.BufferedReader;
import java.io.InputStreamReader;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nexus.simplify.logic.usercommand.UserCommand;
import com.nexus.simplify.parser.core.CoreParser;
import com.nexus.simplify.parser.data.CommandData;
import com.nexus.simplify.parser.tokeniser.Tokeniser;

/**
 * A facade to facilitate interaction between Parser component with other
 * components.
 * 
 * The coding style was used as a guide for all code in Parser component. It can
 * be found in the link below. Coding Style: {@link https
 * ://docs.google.com/a/nuscomputing.com/document/pub?id=1
 * iAESIXM0zSxEa5OY7dFURam_SgLiSMhPQtU0drQagrs&amp}
 * 
	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\api\Parser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\CoreParser.java
	 */


package com.nexus.simplify.parser.core;

public class CoreParser extends TokenParser {
	private static OperationParser _opParser = new OperationParser();
	private static ParamParser _paramParser = new ParamParser();

	final String MESSAGE_UNPARSED_TOKENS = "Unparsed tokens detected: %1$s";

	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		tokenList = _opParser.parseTokens(tokenList);
		tokenList = _paramParser.parseTokens(tokenList);

		// There should not be remaining unidentified tokens who are not
		// recognised as operation or parameters
		if (!isTokenListEmpty(tokenList)) {
			throw new Exception(appendStringArr(MESSAGE_UNPARSED_TOKENS,
					tokenList));
		}
		return tokenList;
	}

	private String appendStringArr(String string, String[] stringArr) {
		String newString = string;
		for (String str : stringArr) {
			string += " " + str;
		}
		return newString;
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\CoreParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\DateTimeParser.java
	 */


package com.nexus.simplify.parser.core;

import java.util.Date;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nexus.simplify.logic.usercommand.OperationType;
import com.nexus.simplify.parser.data.CommandData;
import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

/**
 * 
 * 
 * This DateTime parser relies heavily on Natty library @
 * http://natty.joestelmach.com}
 * 
	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\DateTimeParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\DisplayParser.java
	 */


package com.nexus.simplify.parser.core;

import com.nexus.simplify.parser.data.CommandData;

/**
 * Parses display preference string. This parser is called immediately when
 * display command is parsed.
 * 
	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\DisplayParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\FileLocationParser.java
	 */


package com.nexus.simplify.parser.core;

import com.nexus.simplify.parser.data.CommandData;

public class FileLocationParser extends TokenParser {
	String usedTokens;
	CommandData commandData = CommandData.getInstance();
	String id;
	String filePathString;

	/**
	 * Parses tokenList for filelocation tokens.
	 */
	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			id = tokenList[0];
			if (id.equalsIgnoreCase("filelocation")
					|| id.equalsIgnoreCase("file location")) {
				filePathString = tokenList[1];
				commandData.setFileLocation(filePathString);

				usedTokens = tokenList[0] + " " + tokenList[1];
				return getRemainingTokens(usedTokens, tokenList);
			}
			return tokenList;
		}
	}

}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\FileLocationParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\IndexParser.java
	 */


package com.nexus.simplify.parser.core;

import com.nexus.simplify.parser.data.CommandData;

public class IndexParser extends TokenParser {
	CommandData commandData = CommandData.getInstance();

	/**
	 * Parses tokenList for index tokens.
	 */
	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			String index = tokenList[0];
			if (index.matches("[0-9]+")) {
				commandData.setTaskIndex(index);
				return getRemainingTokens(index, tokenList);
			}
			return tokenList;
		}
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\IndexParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\NameParser.java
	 */


package com.nexus.simplify.parser.core;

import com.nexus.simplify.parser.data.CommandData;

/**
 * Parsing of name works by parsing the remaining tokens as new task name after
 * all other parameters had been parsed.
 *
 */
public class NameParser extends TokenParser {
	CommandData commandData = CommandData.getInstance();

	/**
	 * Parses remaining tokens in tokenList as name tokens.
	 */
	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			if (isEnclosedInDoubleQuotes(tokenList)) {
				tokenList = trimQuotesInTokens(tokenList);
			}
			String name = tokenListToStr(tokenList);
			commandData.setNewName(name);
			return getRemainingTokens(name, tokenList);
		}
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\NameParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\OperationParser.java
	 */


package com.nexus.simplify.parser.core;

import com.nexus.simplify.logic.usercommand.OperationType;
import com.nexus.simplify.parser.data.CommandData;

public class OperationParser extends TokenParser {
	private static final CommandData commandData = CommandData.getInstance();
	private static final DisplayParser displayParser = new DisplayParser();
	private static final IndexParser indexParser = new IndexParser();
	private static final FileLocationParser fileLocationParser = new FileLocationParser();
	/**
	 * Parses tokenList for operation tokens.
	 */
	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			String opString = tokenList[0].toLowerCase();
			tokenList[0] = opString;
			OperationType userOp = commandData.getOperationType(opString);

			// Implement adding of task without providing keywords for add e.g
			// "add"
			if (userOp == OperationType.INVALID) {
				userOp = OperationType.ADD;
				opString = "";
			}

			String[] remainingTokens = getRemainingTokens(opString, tokenList);
			remainingTokens = switchUserOperation(userOp, remainingTokens);
			return remainingTokens;
		}
	}

	/**
	 * Switch case statements for user specified operation. Remove used
	 * operation token from remainingTokens
	 * 
	 * @param userOp			User specified operation token.
	 * @param remainingTokens	List of remaining tokens to be parsed.
	 * @return					List of remaining tokens with userOp remove.
	 * @throws Exception		When parsing of specified token list fails. 
	 */
	private String[] switchUserOperation(OperationType userOp,
										String[] remainingTokens) throws Exception {
		// Handle commands that have special first parameters
		switch (userOp) {
			case DISPLAY:
				commandData.setOp(userOp);
				return displayParser.parseTokens(remainingTokens);
	
			case MODIFY:
				commandData.setOp(userOp);
				String[] postIndexParseTokens = indexParser
						.parseTokens(remainingTokens);
				if (postIndexParseTokens.equals(remainingTokens)) {
					return fileLocationParser.parseTokens(remainingTokens);
				} else {
					return postIndexParseTokens;
				}
	
			case DONE:
				commandData.setOp(userOp);
				return indexParser.parseTokens(remainingTokens);
	
			case DELETE:
				commandData.setOp(userOp);
				return indexParser.parseTokens(remainingTokens);
	
			default:
				commandData.setOp(userOp);
				return remainingTokens;
		}
	}
}
	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\OperationParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\ParamParser.java
	 */


package com.nexus.simplify.parser.core;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ParamParser extends TokenParser {
	private static final DateTimeParser dtParser = new DateTimeParser();
	private static final WorkloadParser wlParser = new WorkloadParser();
	private static final NameParser nameParser = new NameParser();
	private static final Logger LOGGER = LoggerFactory
			.getLogger(CoreParser.class.getName());

	private static final String LOG_PASRING_ERROR = "Parse Error on: {}";

	/**
	 * Parses unused tokens in tokenList for all parameters types.
	 */
	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			try {
				// Parse DateTime tokens.
				tokenList = dtParser.parseTokens(tokenList);

				// Parse workload tokens.
				tokenList = wlParser.parseTokens(tokenList);

				// Remaining tokens are taken to be new name as it is the last
				// type of supported parameters
				tokenList = nameParser.parseTokens(tokenList);
				return tokenList;
			} catch (Exception e) {
				LOGGER.error(LOG_PASRING_ERROR, tokenList, e);
				throw e;
			}
		}

	}

}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\ParamParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\TokenParser.java
	 */


package com.nexus.simplify.parser.core;

/**
 * An abstract class to generalise the role of token parsers in Parser
 * component. TokenParser contains many useful methods that parsers might need
 * while they parse for specific type of tokens
 *
 */
public abstract class TokenParser {
	// Char value of double quote ("), used for detection in tokens
	protected final char DOUBLE_QUOTE = 34;

	private final int ARRAY_EMPTY_SIZE = 0;
	private final String EMPTY_TOKEN = "";

	/**
	 * Takes a list of tokens and process the tokens that it is able to parse.
	 * 
	 * @param tokenList
	 *            List of tokens to be parsed.
	 * @return List of remaining tokens that were not used.
	 * @throws Exception
	 *             When parsing of specified token list fails.
	 */
	public abstract String[] parseTokens(String[] tokenList) throws Exception;

	/**
	 * Returns a list of tokens with all tokens in usedTokens removed.
	 * 
	 * @param usedTokens	List of tokens to be removed.
	 * @param tokenList		List of tokens containing usedTokens.
	 * @return				List of tokens with tokens in usedTokens removed.
	 */
	protected String[] getRemainingTokens(String usedTokens, String[] tokenList) {
		// Specified token list cannot be a null object, else there is nothing
		// to remove tokens from.
		assert (usedTokens != null);

		if (usedTokens.equals(EMPTY_TOKEN)) {
			return tokenList;
		}

		String[] usedTokenList = strToTokenList(usedTokens);
		// You cannot use up more tokens than it is provided.
		assert (usedTokenList.length <= tokenList.length);

		String[] newTokenList = new String[tokenList.length
				- usedTokenList.length];
		String[] tempTokenList = replaceTokensWithNull(tokenList, usedTokenList);
		String[] remainingTokens = removeNullTokens(newTokenList, tempTokenList);
		return remainingTokens;
	}

	/**
	 * Return {@code true} if the specified array contains {@code null} element.
	 * 
	 * @param tokenList
	 *            Token list to be checked for {@code null} element.
	 * @return {@code true} if token list contains null element, {@code false}
	 *         if otherwise.
	 */
	protected boolean hasNull(String[] tokenList) {
		for (int i = 0; i < tokenList.length; i++) {
			String string = tokenList[i];
			if (string == null) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Transfer non-null elements from oldTokenList to newTokenList. Length of
	 * newTokenList specified must be exactly the same with number of non-null
	 * elements.
	 * 
	 * @param newTokenList
	 *            New empty token that has the length of non {@code null}
	 *            elements in oldTokenList.
	 * @param oldTokenList
	 *            List of tokens with {@code null} elements.
	 * @return New token list that is fully filled with tokens.
	 */
	protected String[] removeNullTokens(String[] newTokenList,
										String[] oldTokenList) {
		// Populate newTokenList with remaining unused tokens.
		if (newTokenList.length == ARRAY_EMPTY_SIZE) {
			return newTokenList;
		} else {
			int count = 0;

			for (int i = 0; i < oldTokenList.length; i++) {
				if (oldTokenList[i] != null) {
					newTokenList[count] = oldTokenList[i];
					count++;
				}
			}

			// New list should be fully filled. Presence of null suggests that
			// more than one remaining token was not brought over
			assert (!hasNull(newTokenList));
			return newTokenList;
		}
	}

	/**
	 * Clones the specified token list and replacing tokens found in used token
	 * list with {@code null}.
	 * 
	 * @param tokenList
	 *            List of tokens to remove tokens from.
	 * @param usedTokenList
	 *            List of tokens to be removed.
	 * @return tokenList with used tokens filled with {@code null}.
	 */
	protected String[] replaceTokensWithNull(String[] tokenList,
											String[] usedTokenList) {
		String[] tempTokenList = tokenList.clone();

		for (int i = 0; i < tempTokenList.length; i++) {
			for (int j = 0; j < usedTokenList.length; j++) {
				if (usedTokenList[j].equals(tempTokenList[i])) {
					tempTokenList[i] = null;
				}
			}
		}
		return tempTokenList;
	}

	/**
	 * Returns {@code true} if specified tokenList contains at least one token
	 * enclosed in double quotations.
	 * 
	 * @param tokenList
	 *            List of tokens.
	 * @return {@code true} if tokenList contains at least one token enclosed in
	 *         double quotations, otherwise {@code false}.
	 */
	protected boolean isEnclosedInDoubleQuotes(String[] tokenList) {
		boolean first = false;
		boolean second = false;
		String[] temp = tokenList.clone();

		// Search for a pair of quotation marks in the whole array
		for (int i = 0; i < temp.length; i++) {
			String string = temp[i];
			final int startOfString = 0;
			final int endOfString = string.length() - 1;

			if (string.charAt(startOfString) == DOUBLE_QUOTE) {
				first = true;
			}

			if (first && string.charAt(endOfString) == DOUBLE_QUOTE) {
				second = true;
			}
		}
		return first && second;
	}

	/**
	 * Removes words enclosed in a pair of double quotation marks from a token
	 * array.
	 * 
	 * @param tokenList
	 *            List of tokens to be trimmed.
	 * @return tokenList without words enclosed in a pair of double quotation
	 *         marks.
	 */
	protected String[] trimTokensInQuotes(String[] tokenList) {
		String[] temp = tokenList.clone();
		int start = -1;
		int end = -1;

		for (int i = 0; i < temp.length; i++) {
			String string = temp[i];
			final int startOfString = 0;
			final int endOfString = string.length() - 1;

			if (string.charAt(startOfString) == DOUBLE_QUOTE) {
				start = i;
			}

			if (start >= 0 && string.charAt(endOfString) == DOUBLE_QUOTE) {
				end = i;
			}
		}

		int lengthOfTrimmed = (end - start + 1);
		String[] remaining = new String[temp.length - lengthOfTrimmed];

		// keep partition that is left of trimmed
		for (int i = 0; i < start; i++) {
			remaining[i] = temp[i];
		}

		// keep partition that is right of trimmed
		for (int i = (end + 1); i < temp.length; i++) {
			remaining[i - lengthOfTrimmed] = temp[i];
		}
		return remaining;
	}

	/**
	 * Trims double quotation marks that encloses at least one tokens.
	 * 
	 * @param tokenList
	 *            List of tokens.
	 * @return List of tokens where no tokens are enclosed in double quotes.
	 */
	protected String[] trimQuotesInTokens(String[] tokenList) {
										String[] temp = tokenList.clone();

		for (int i = 0; i < temp.length; i++) {
			String string = temp[i];
			final int startOfString = 0;
			final int endOfString = string.length() - 1;
			final int startOfTrimmed = 1;

			if (string.charAt(startOfString) == DOUBLE_QUOTE
					&& string.charAt(endOfString) == DOUBLE_QUOTE) {
				temp[i] = string.substring(startOfTrimmed, endOfString);
			} else {
				temp[i] = string.replaceFirst("\"", EMPTY_TOKEN);
			}
		}
		return temp;
	}

	/**
	 * Returns {@true} if specified tokenList is an empty array.
	 * 
	 * @param tokenList
	 *            List of tokens.
	 * @return {@true} if specified tokenList is an empty array.
	 */
	protected boolean isTokenListEmpty(String[] tokenList) {
		// Case when all tokens are used up by the parsers
		if (tokenList.length == 0) {
			return true;
			// Case when empty string "" is entered by user
		} else if (tokenList.length == 1 & tokenList[0].equals(EMPTY_TOKEN)) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Tokenises a tokenString by splitting tokenString into substrings
	 * separated by one or more whitespaces.
	 * 
	 * @param tokenString
	 *            A string containing tokens separated by whitespaces.
	 * @return List of all tokens contained in tokenString.
	 */
	protected String[] strToTokenList(String tokenString) {
		String[] tokenList = tokenString.split("\\s+");
		return tokenList;
	}

	/**
	 * Concatenate tokens in tokenList to one long token string with tokens
	 * seperated by single whitespace.
	 * 
	 * @param tokenList
	 *            List of tokens to be concatenated.
	 * @return A long string containing all tokens in tokenList seperated by
	 *         single whitespace.
	 */
	protected String tokenListToStr(String[] tokenList) {
		StringBuilder builder = new StringBuilder();
		for (String s : tokenList) {
			builder.append(s);
			builder.append(" ");
		}
		return builder.toString().trim();
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\TokenParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\WorkloadParser.java
	 */


package com.nexus.simplify.parser.core;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nexus.simplify.parser.data.CommandData;

public class WorkloadParser extends TokenParser {
	Logger LOGGER = LoggerFactory.getLogger(WorkloadParser.class.getName());
	CommandData commandData = CommandData.getInstance();

	final int INDEX_START_OF_WORKLOAD = 1;
	

	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			boolean workloadFound = false;
			String workloadString = null;
			String workloadValueString = null;
			for (int i = 0; i < tokenList.length; i++) {
				String currentToken = tokenList[i];

				if (currentToken.matches("[wW][1-5]")) {
					if (workloadFound) {
						throw new Exception("More than one workload values were present. Please specify one workload value only.");
					}
					workloadString = tokenList[i];
					workloadValueString = workloadString.substring(INDEX_START_OF_WORKLOAD);
					commandData.setWorkload(workloadValueString);
					workloadFound = true;
				}
			}
			if (workloadFound) {
				return getRemainingTokens(workloadString, tokenList);
			} else {
				return tokenList;
			}
		}

	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\WorkloadParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\data\CommandData.java
	 */


package com.nexus.simplify.parser.data;

import java.util.Arrays;
import java.util.HashMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nexus.simplify.logic.usercommand.OperationType;
import com.nexus.simplify.logic.usercommand.ParameterType;
import com.nexus.simplify.logic.usercommand.UserCommand;

/**
 * A singleton which holds data such as the user specified operation and
 * parameters from parsing of token lists generated from user command string
 * input.
 *
 */
public class CommandData {
	private static final String LOG_COMMAND_DATA = "User Operation: {}. User Parameters: {}. Search Boolean: {}";

	private static CommandData _instance = null;
	private static OperationType _userOp;
	private static String[] _paramArray;
	private static boolean[] _searchArray;
	private static HashMap<String, OperationType> _cmdHash = new HashMap<String, OperationType>();
	private static Logger LOGGER = LoggerFactory.getLogger(CommandData.class
			.getName());

	/**
	 * Returns {@code CommandData} singleton. Replaces a constructor as
	 * singletons are implemented as "static" classes. getInstance method will
	 * create a static instance of CommandData if CommandData was not
	 * instantiated.
	 * 
	 * @return The only instance of CommandData.
	 */
	public static CommandData getInstance() {
		if (_instance == null) {
			_instance = new CommandData();
		}
		return _instance;
	}

	/**
	 * Return a newly created {@link UserCommand} object which is populated with
	 * operation requested and various parameters in a string array. Parameter
	 * types that are not provided are left as {@code null}.
	 * 
	 * Stored data is reset after UserCommand is created.
	 * 
	 * @return UserCommand object with user specified operation and parameters.
	 */
	public UserCommand createCommand() {
		OperationType tempOp = _userOp;
		String[] tempParam = _paramArray.clone();
		boolean[] tempSearch = _searchArray.clone();
		_userOp = null;
		_paramArray = new String[ParameterType.MAX_SIZE];
		LOGGER.info(LOG_COMMAND_DATA, tempOp, Arrays.toString(tempParam),
				Arrays.toString(tempSearch));
		return new UserCommand(tempOp, tempParam, tempSearch);
	}

	/**
	 * Set specified operation type to class variable.
	 * 
	 * @see OperationType
	 */
	public void setOp(OperationType userOp) {
		_userOp = userOp;
	}

	/**
	 * Sets user operation type to OperationType.INVALID.
	 * 
	 * @see OperationType
	 */
	public void setInvalidOp() {
		_userOp = OperationType.INVALID;
	}

	/**
	 * Sets the specified display preference string in CommandData parameter
	 * array.
	 * 
	 * @param displayPref
	 *            The type of display action that the user wants.
	 */
	public void setDisplay(String displayPref) {
		// Logic will take display preference string from index paramater
		// position in the parameter array
		_paramArray[ParameterType.INDEX_POS] = displayPref;
	}

	/**
	 * Sets the specified task index in CommandData parameter array.
	 * 
	 * @param taskIndex
	 *            Index of a task as shown on Simplify's UI.
	 */
	public void setTaskIndex(String taskIndex) {
		_paramArray[ParameterType.INDEX_POS] = taskIndex;
	}

	/**
	 * Sets the specified task index in CommandData parameter array.
	 * 
	 * @param taskIndex
	 */
	public void setNewName(String name) {
		_paramArray[ParameterType.NEW_NAME_POS] = name;
	}

	/**
	 * Sets the specified single DateTime in CommandData parameter array.
	 * 
	 * @param time
	 *            String representation of java DateTime.
	 */
	public void setTime(String time) {
		_paramArray[ParameterType.NEW_STARTTIME_POS] = time;
		_paramArray[ParameterType.NEW_ENDTIME_POS] = time;
	}

	/**
	 * Sets the specified starting and ending DateTime in CommandData parameter
	 * array.
	 * 
	 * @param time1
	 *            String representation of starting DateTime specified by user.
	 * @param time2
	 *            String representation of ending DateTime specified by user.
	 */
	public void setTime(String time1, String time2) {
		_paramArray[ParameterType.NEW_STARTTIME_POS] = time1;
		_paramArray[ParameterType.NEW_ENDTIME_POS] = time2;
	}

	/**
	 * Sets the specified string representation of workload integer value in
	 * CommandData parameter array.
	 * 
	 * @param workload
	 *            String representation of workload integer value.
	 */
	public void setWorkload(String workload) {
		_paramArray[ParameterType.NEW_WORKLOAD_POS] = workload;
	}

	/**
	 * Sets boolean value to {@code true} to signal that the user has searched
	 * for a year value.
	 */
	public void setYearSearch() {
		_searchArray[ParameterType.SEARCH_YEAR_POS] = true;
	}

	/**
	 * Sets boolean value to {@code true} to signal that the user has searched
	 * for a month value.
	 */
	public void setMonthSearch() {
		_searchArray[ParameterType.SEARCH_MONTH_POS] = true;
	}

	/**
	 * Sets boolean value to {@code true} to signal that the user has searched
	 * for a day of month value.
	 */
	public void setDayOfMonthSearch() {
		_searchArray[ParameterType.SEARCH_DAY_POS] = true;
	}

	/**
	 * Sets boolean value to {@code true} to signal that the user has searched
	 * for a weekday value.
	 */
	public void setDayOfWeekSearch() {
		_searchArray[ParameterType.SEARCH_WEEKDAY_POS] = true;
	}

	/**
	 * Sets boolean value to {@code true} to signal that the user has searched
	 * for an hour value.
	 */
	public void setHourSearch() {
		_searchArray[ParameterType.SEARCH_HOUR_POS] = true;
	}

	/**
	 * Returns the OperationType that corresponds to the specified keyword
	 * string.
	 * 
	 * @param keyword
	 *            String for user specified operation command keyword.
	 * @return Corresponding OperationType for the specified keyword. Return an
	 *         invalid OperationType if specified keyword does not map to any
	 *         operation.
	 */
	public OperationType getOperationType(String keyword) {
		if (_cmdHash.containsKey(keyword)) {
			return _cmdHash.get(keyword);
		} else {
			return OperationType.INVALID;
		}

	}

	/**
	 * Returns the OperationType that is stored in CommandData that may have be
	 * set previously
	 * 
	 * @return OperationType that is stored in Command Data. Returns
	 *         {@code null} if no OperationType was set.
	 */
	public OperationType getUserOp() {
		return _userOp;
	}

	/**
	 * Hidden constructor for CommandData so that no new instance of CommandData can be made externally. 
	 * 
	 * Initialise command string hashtable by adding all recognised command
	 * strings as keys to respective OperationType.
	 *
	 */
	private CommandData() {
		initOpHash();

		for (int i = 0; i < _searchArray.length; i++) {
			_searchArray[i] = false;
		}

	}

	/**
	 * Adds all supported operation keyword into HashMap with the corresponding
	 * OperationType
	 */
	private void initOpHash() {
		// Adding support for all supported commands
		_cmdHash.put("display", OperationType.DISPLAY);
		_cmdHash.put("show", OperationType.DISPLAY);
		_cmdHash.put("add", OperationType.ADD);
		_cmdHash.put("a", OperationType.ADD);
		_cmdHash.put("put", OperationType.ADD);
		_cmdHash.put("p", OperationType.ADD);
		_cmdHash.put("modify", OperationType.MODIFY);
		_cmdHash.put("m", OperationType.MODIFY);
		_cmdHash.put("change", OperationType.MODIFY);
		_cmdHash.put("update", OperationType.MODIFY);
		_cmdHash.put("delete", OperationType.DELETE);
		_cmdHash.put("remove", OperationType.DELETE);
		_cmdHash.put("done", OperationType.DONE);
		_cmdHash.put("finish", OperationType.DONE);
		_cmdHash.put("clear", OperationType.CLEAR);
		_cmdHash.put("exit", OperationType.EXIT);
		_cmdHash.put("quit", OperationType.EXIT);
		_cmdHash.put("undo", OperationType.UNDO);
		_cmdHash.put("u", OperationType.UNDO);
		_cmdHash.put("search", OperationType.SEARCH);
		_cmdHash.put("s", OperationType.SEARCH);
		_cmdHash.put("find", OperationType.SEARCH);
		_paramArray = new String[ParameterType.MAX_SIZE];
		_searchArray = new boolean[ParameterType.SEARCH_MAX_SIZE];
	}

	public void setFileLocation(String filePathString) {
		_paramArray[ParameterType.NEW_FILELOCATION_POS] = filePathString;

	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\data\CommandData.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\tokeniser\Tokeniser.java
	 */


package com.nexus.simplify.parser.tokeniser;

/**
 * A tokeniser that splits a string into substrings that are seperated by
 * whitespaces.
 *
 */
public class Tokeniser {

	private static final String REGEX_WHITESPACE_ONCE_OR_MORE = "\\s+";

	/**
	 * Lexical analyser which takes in a string and produces a list of tokens. A
	 * token in Simplify is a combination of character sequences seperated by
	 * one whitespace character
	 * 
	 * @param userInput
	 *            Input string from user.
	 * @return An array of string tokens.
	 */
	public String[] tokenise(String userInput) {
		String[] stringArray = userInput.split(REGEX_WHITESPACE_ONCE_OR_MORE);
		return stringArray;
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\tokeniser\Tokeniser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\AbstractIntegrationTest.java
	 */


package com.nexus.simplify.test;

import static org.junit.Assert.*;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import org.junit.Assert;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;
import com.nexus.simplify.MainApp;
import com.nexus.simplify.database.api.Database;
import com.nexus.simplify.database.core.LogicRequest;
import com.nexus.simplify.logic.api.Logic;
import com.nexus.simplify.logic.usercommand.UserCommand;
import com.nexus.simplify.parser.data.CommandData;

public abstract class AbstractIntegrationTest {
	private static MainApp _main;
	protected static Logic _logic;
	protected static Database _db;
	protected static LogicRequest _logicRequest;
	protected static UserCommand parsedCommand;
	protected static Parser _natty;

	public static void initMainApp() {
		try {
			_main = new MainApp();
			_logic = _main.getLogic();
			_db = MainApp.getDatabase();
			_logicRequest = _db.getLogicRequest();
			_natty = new Parser();

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Parses the given value into a collection of dates
	 * 
	 * @param value
	 * @return
	 */
	protected List<Date> parseCollection(String value) {
		List<DateGroup> dateGroup = _natty.parse(value);
		List<Date> dates = dateGroup.get(0).getDates();
		return dates;
	}

	/**
	 * Parses the given value, asserting that one and only one date is produced.
	 * 
	 * @param value
	 * @return
	 */
	protected Date parseSingleDate(String value) {
		if (value == null) {
			return null;
		}
		List<Date> dates = parseCollection(value);
		Assert.assertEquals(1, dates.size());
		return dates.get(0);
	}

	/**
	 * Asserts that the given user input is what Parser receives.
	 * 
	 * @param expected
	 * @throws Exception 
	 */
	protected void validateParserInput(String userInput) throws Exception {
		_logic.getParser().parseInput(userInput);
		String actual = _logic.getParser().getGivenInput();
		assertEquals(userInput, actual);
	}

	/**
	 * validates the input of parser and then proceed with parsing a single user input 
	 * 
	 * @param userInput
	 * @return
	 */
	protected UserCommand parseSingleInput(String userInput) {
		try {
			validateParserInput(userInput);
			parsedCommand = _logic.getParsedCommand(userInput);			

		} catch (Exception e) {
			e.printStackTrace();
		}
		return parsedCommand;
	}

	/**
	 * Converts a natural datetime string into Java date string representation
	 * @param dateTime
	 * @return
	 */
	protected String naturalToJavaString(String dateTime) {
		Date java = null;
		java = parseSingleDate(dateTime); 
		if (java == null) {
			return null;
		} else {
			return java.toString();
		}
	}


	/**
	 * Asserts that the given user input parses into the given index, name, start time, end time
	 * 
	 * @param userInput
	 * @param index
	 * @param name
	 * @param startTime
	 * @param endTime
	 * @param workload
	 * @param fileLocation
	 */
	protected UserCommand validateParsedCommand(String userInput, String operation, String index, String name, 
			String startTime, String endTime, Object workload, String fileLocation) {
		startTime = naturalToJavaString(startTime);
		endTime = naturalToJavaString(endTime);
		parsedCommand = parseSingleInput(userInput);
		assertEquals(CommandData.getInstance().getOperationType(operation), parsedCommand.getOperationType());
		assertEquals(index, parsedCommand.getIndex());
		assertEquals(name, parsedCommand.getName());
		assertEquals(removeSeconds(startTime), removeSeconds(parsedCommand.getStartTime()));
		assertEquals(removeSeconds(endTime), removeSeconds(parsedCommand.getEndTime()));
		assertEquals(workloadToString(workload), parsedCommand.getWorkload());
		assertEquals(fileLocation, parsedCommand.getFileLocation());
		return parsedCommand;
	}


	protected Date javaDateStringToDate(String javaDate) {
		String pattern = "E MMM dd hh:mm:ss zzz yyy";
		SimpleDateFormat df = new SimpleDateFormat(pattern);
		Date date = null;
		try {
			date = df.parse(javaDate);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		return date;
	}

	protected Object indexStringToInt(String string) {
		if (string == null) {
			return null;
		} else {
			int index = Integer.parseInt(string);
			return index;
		}
	}

	protected String workloadToString(Object workload) {
		if (workload == null) {
			return null;
		} else {
			return Integer.toString((int)workload);
		}
	}

	protected int normaliseWorkload(Object workload) {
		if (workload == null) {
			return 0;
		} else {
			return Integer.parseInt((String)workload);
		}
	}

	protected void validateCallOnDatabase(String userInput, UserCommand userCommand) {
		try {
			_logic.executeCommand(userInput);
		} catch (Exception e) {
			e.printStackTrace();
		}
		assertEquals(userCommand.getOperationType(), _logicRequest.getOperationType());
		assertEquals(indexStringToInt(userCommand.getIndex()), _logicRequest.getIndex());
		assertEquals(userCommand.getName(), _logicRequest.getName());
		assertEquals(parseSingleDate(userCommand.getStartTime()), _logicRequest.getStartTime());
		assertEquals(parseSingleDate(userCommand.getEndTime()), _logicRequest.getEndTime());
		assertEquals(normaliseWorkload(userCommand.getWorkload()), _logicRequest.getWorkload());
		assertEquals(userCommand.getFileLocation(), _logicRequest.getFileLocation());
	}

	protected void testSingleInput(String userInput, String operation, String index, String name, String startTime, 
			String endTime, Object workload, String fileLocation) {
		UserCommand userCommand = validateParsedCommand(userInput, operation, index, name, startTime, endTime, workload, fileLocation);
		validateCallOnDatabase(userInput, userCommand);
	}
	
	// Mon Apr 11 12:54:27 SGT 2016
	private String removeSeconds(String DateTime) {
		if (DateTime == null) {
			return null;
		}
		assert(DateTime.length() == 23);
		String left = DateTime.substring(0, 17);
		String right = DateTime.substring(19);
		return left+right;
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\AbstractIntegrationTest.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\AllTests.java
	 */


package com.nexus.simplify.test;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;

import com.nexus.simplify.test.database.DatabaseTest;
import com.nexus.simplify.test.logic.TestAdd;
import com.nexus.simplify.test.logic.TestDelete;
import com.nexus.simplify.test.logic.TestDisplay;
import com.nexus.simplify.test.logic.TestDone;
import com.nexus.simplify.test.logic.TestModify;
import com.nexus.simplify.test.parser.ParserTest;
import com.nexus.simplify.test.ui.CommandHistoryTest;

@RunWith(Suite.class)
@SuiteClasses({
    
	MultipleIntegrationsTest.class,
    
	// Parser Unit Tests
	ParserTest.class,
	
	// Logic Unit Tests
	TestAdd.class,
	TestDelete.class,
	TestDisplay.class,
	TestDone.class,
	TestModify.class,
    
	// Database Unit Tests
	DatabaseTest.class,
	
	// UI Unit Test
	CommandHistoryTest.class
})

public class AllTests {}
	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\AllTests.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\MultipleIntegrationsTest.java
	 */


package com.nexus.simplify.test;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 * System Testing for Add command
 */
public class MultipleIntegrationsTest extends AbstractIntegrationTest {

	@BeforeClass
	public static void oneTime() {
		initMainApp();
	}

	@Before
	public void resetLogicRequest(){
		_logicRequest.reset();
	}

	@Test
	public void testTimedTask() {
		testSingleInput("add drink coffee 8pm - 9pm", "add", null, "drink coffee", 
				"8pm", "9pm", null, null);
		testSingleInput("a meeting w5 tomorrow 2pm to 4pm", "add",  null, "meeting", 
				"tomorrow 2pm", "tomorrow 4pm", 5, null);
		testSingleInput("add dinner with tom tomorrow 1400 - 1600", "add",  null, "dinner with tom", 
				"tomorrow 1400", "tomorrow 1600", null, null);
		testSingleInput("add camping tomorrow 12pm to 8 pm 2 weeks from now w1", "add",  null, "camping",
				"tomorrow 12pm", "8pm 2 weeks from now", 1, null);

	}

	@Test
	public void testDeadlineTask() {
		testSingleInput("add V0.3 Demo tomorrow 3pm", "add",  null, "V0.3 Demo",
				"tomorrow 3pm", "tomorrow 3pm", null, null);
		testSingleInput("a V0.3 Demo 1 Apr 3pm w4", "add",  null, "V0.3 Demo",
				"1 Apr 3pm", "1 Apr 3pm", 4, null);
		testSingleInput("add V0.3 Demo w3 next week", "add",  null, "V0.3 Demo",
				"next week", "next week", 3, null);
		testSingleInput("add V0.3 Demo w5 5 days from now", "add",  null, "V0.3 Demo",
				"5 days from now", "5 days from now", 5, null);
	}

	@Test
	public void testGenericTask() {
		testSingleInput("add train for ippt w5", "add",  null, "train for ippt",
				null, null, 5, null);
		testSingleInput("a read", "add",  null, "read",
				null, null, null, null);
		testSingleInput("add learn web dev w5", "add",  null, "learn web dev",
				null, null, 5, null);
		testSingleInput("add catch up on lectures", "add",  null, "catch up on lectures",
				null, null, null, null);
	}

}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\MultipleIntegrationsTest.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\parser\ParserTest.java
	 */


package com.nexus.simplify.test.parser;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.nexus.simplify.test.AbstractIntegrationTest;

import edu.emory.mathcs.backport.java.util.Arrays;

/**
 * Unit Test class for Parser component. 
 * 
 * Actual input command string is given to Parser.parse method. 
 * DateTime input used are supported by natty at http://natty.joestelmach.com/try.jsp
 * Unsupported DateTime strings will be taken to be name of the task, thus there will be error during comparison 
 * if the intended DateTime string is not recognised as a DateTime
 * Results from parsing are stored in CommandData and the values are taken for comparison
 * 
 * Expected output are manually specified, individually.
 * Expected DateTime output is the DateTime that natty library parses from the given string 
 * that implies DateTime Element
 * 
 *
 */
public class ParserTest extends AbstractIntegrationTest {
	final String DISPLAY = "display";
	final String ADD = "add";
	final String MODIFY = "modify";
	final String DELETE = "delete";
	final String CLEAR = "clear";
	final String DONE = "done";
	final String UNDO = "undo";
	final String SEARCH = "search";
	final String TEST_NAME = "Parser Unit Testing";

	@BeforeClass
	public static void oneTime() {
		initMainApp();
	}

	@Before
	public void resetLogicRequest(){
		_logicRequest.reset();
	}

	@Test
	public void testDisplay() {
		validateParsedCommand("display", DISPLAY, null, null, null, null, null, null);
		validateParsedCommand("display week", DISPLAY, "week", null, null, null, null, null);
		validateParsedCommand("display deadline", DISPLAY, "deadline", null, null, null, null, null);
		validateParsedCommand("display default", DISPLAY, "default", null, null, null, null, null);

		// invalid display parameters
		validateParsedCommand("display -1", DISPLAY, "-1", null, null, null, null, null);
		validateParsedCommand("display .", DISPLAY, ".", null, null, null, null, null);
		validateParsedCommand("display asdasd9808", DISPLAY, "asdasd9808", null, null, null, null, null);
	}

	@Test
	public void testAddName() {
		// Empty string boundary case for no name partition 
		validateParsedCommand("add", ADD, null, null, null, null, null, null);

		// " " string boundary case for whitespace parameter partition 
		validateParsedCommand("add  ", ADD, null, null, null, null, null, null);

		// "." string boundary case for valid name partition
		validateParsedCommand("add .", ADD, null, ".", null, null, null, null);

		// very long string boundary case for valid name partition
		char[] manyChars = new char[5000];
		Arrays.fill(manyChars, "a".charAt(0));
		String longString = new String(manyChars);
		validateParsedCommand("add " + longString, ADD, null, longString, null, null, null, null);

		// trailing whitespace
		validateParsedCommand("a trailing ", ADD, null, "trailing", null, null, null, null);
		validateParsedCommand("add trailing  ", ADD, null, "trailing", null, null, null, null);

		// leading whitespace
		validateParsedCommand("add  leading ", ADD, null, "leading", null, null, null, null);
		validateParsedCommand("add   leading  ", ADD, null, "leading", null, null, null, null);

		// cases to stress-test Parser  
		// words with a mix of digits
		validateParsedCommand("add CS2100", ADD, null, "CS2100", null, null, null, null);
		// name contains word that contains workload param
		validateParsedCommand("add w1w1", ADD, null, "w1w1", null, null, null, null);
	}

	@Test
	public void testAddDeadline() {
		// Natty supported common English phrases used to denote date
		validateAddSingleDateTime("tomorrow");
		validateAddSingleDateTime("day after tomorrow");
		validateAddSingleDateTime("week after tomorrow");

		validateAddSingleDateTime("next day");
		validateAddSingleDateTime("next Monday");
		validateAddSingleDateTime("next week");
		validateAddSingleDateTime("next month");
		validateAddSingleDateTime("next year");
		validateAddSingleDateTime("next spring");
		validateAddSingleDateTime("next summer");
		validateAddSingleDateTime("next autumn");
		validateAddSingleDateTime("next winter");

		validateAddSingleDateTime("upcoming day");
		validateAddSingleDateTime("upcoming Sunday");
		validateAddSingleDateTime("upcoming week");
		validateAddSingleDateTime("upcoming month");
		validateAddSingleDateTime("upcoming year");
		validateAddSingleDateTime("upcoming spring");
		validateAddSingleDateTime("upcoming summer");
		validateAddSingleDateTime("upcoming autumn");
		validateAddSingleDateTime("upcoming winter");

		// Specifying specific date
		validateAddSingleDateTime("15 April");
		validateAddSingleDateTime("15 Apr");
		validateAddSingleDateTime("15th Apr");
		validateAddSingleDateTime("15 Apr 2016");
		validateAddSingleDateTime("15 April 2016");
		validateAddSingleDateTime("15/4");
		validateAddSingleDateTime("15/4");
		validateAddSingleDateTime("15/4/2015");
		validateAddSingleDateTime("15 Apr");

		// Specifying Time
		validateAddSingleDateTime("4pm");
		validateAddSingleDateTime("4 pm");
		validateAddSingleDateTime("1600");
		validateAddSingleDateTime("1600h");
		validateAddSingleDateTime("1600 hour");

		//Specifying Date and Time
		validateAddSingleDateTime("tomorrow 4pm");
		validateAddSingleDateTime("next day 1600 pm");
		validateAddSingleDateTime("next Monday 1600");
		validateAddSingleDateTime("next year 1600h");
		validateAddSingleDateTime("next spring 1600 hour");
		validateAddSingleDateTime("week after tomorrow 4pm");
		validateAddSingleDateTime("week after tomorrow 8am");
		validateAddSingleDateTime("week after 17 April 8 am");
		validateAddSingleDateTime("month after 17 April 8");
		validateAddSingleDateTime("day after tomorrow 0800");		

		// boundary case for invalid deadline
		validateParsedCommand("add no deadline 20 apri", ADD, null, "no deadline apri", "20", "20", null, null);
	}

	@Test
	public void testAddGenericWorkload() {
		// boundary case for valid workload
		validateAddNameWorkLoad("LOWEST WORKLOAD", 1);
		validateAddNameWorkLoad("HIGHEST WORKLOAD", 5);

		// boundary case for invalid workload
		validateParsedCommand("add boundary case w0", ADD, null, "boundary case w0", null, null, null, null);
		validateParsedCommand("add boundary case w6", ADD, null, "boundary case w6", null, null, null, null);

		// name contains a word which contains workload param as subsequence
		validateAddNameWorkLoad("w1a", 5);
	}

	@Test
	public void testAddDeadlineWorkload() {
		validateAddNameSingleDateTimeWorkload(TEST_NAME, "tomorrow", 1);

		// boundary case for invalid workload
		validateParsedCommand("add boundary case w0 20 oct", ADD, null, "boundary case w0", "20 oct", "20 oct", null, null);

		// boundary case for invalid name
		validateParsedCommand("add w5 20/04", ADD, null, null, "20/04", "20/04", 5, null);

		// boundary case for invalid deadline
		validateParsedCommand("add no deadline w5 apri", ADD, null, "no deadline apri", null, null, 5, null);

	}

	@Test
	public void testAddTimedWorkload() {
		validateAddNameTimedWorkload("oneword", "8 to 5 pm 19 apr", "8pm 19 apr", "5 pm 19 apr", 5);
		validateAddNameTimedWorkload("two words!", "8am to 5pm 19 apr", "8am 19 apr", "5pm 19 apr", 4);
		validateAddNameTimedWorkload("do parser unit testing", "8am to 2pm", "8am", "2pm", 3);
		validateAddNameTimedWorkload("prepare for CS2101 oral discussion", "1700 to 1900 14 apr", "1700 14 apr", "1900 14 apr", 2);
	}

	@Test
	public void testModify() {
		validateParsedCommand("modify 1 new name!", MODIFY, "1", "new name!", null, null, null, null);
		validateParsedCommand("modify 2 new name!"	, MODIFY, "2", "new name!", null, null, null, null);

		// negative index is invalid and is taken as part of the name
		validateParsedCommand("modify -1 new name!"	, MODIFY, null, "-1 new name!", null, null, null, null);
	}

	@Test
	public void testDelete() {
		validateParsedCommand("delete 1", DELETE, "1", null, null, null, null, null);
		validateParsedCommand("delete 100 workload", DELETE, "100", "workload", null, null, null, null);

		// negative index is invalid and is taken as part of the parameter
		validateParsedCommand("delete -1 deadline", DELETE, null, "-1 deadline", null, null, null, null);
	}

	@Test
	public void testClear() {
		validateParsedCommand("clear", CLEAR, null, null, null, null, null, null);
	}

	@Test
	public void testDone() {
		validateParsedCommand("done", DONE, null, null, null, null, null, null);
	}

	@Test
	public void testUndo() {
		validateParsedCommand("undo", UNDO, null, null, null, null, null, null);
		validateParsedCommand("u", UNDO, null, null, null, null, null, null);
	}

	@Test
	public void testSearch() {
		// search for name
		validateParsedCommand("search looking for a name", SEARCH, null, "looking for a name", null, null, null, null);

		// search directly specified HOURS, DAY OF WEEK, DAY OF MONTH, MONTH or YEAR
		// excludes "search tomorrow"
		validateParsedCommand("search fri", SEARCH, null, null, "fri", "fri", null, null);
		validateParsedCommand("search friday", SEARCH, null, null, "fri", "fri", null, null);
		validateParsedCommand("search apr", SEARCH, null, null, "apr", "apr", null, null);
		validateParsedCommand("search 0930", SEARCH, null, null, "0930", "0930", null, null);
		validateParsedCommand("search year 2020", SEARCH, null, null, "1 Jan 2020", "1 Jan 2020", null, null);
		validateParsedCommand("search 0000 year", SEARCH, null, null, "1 Jan 0000", "1 Jan 0000", null, null);
		validateParsedCommand("search -1 year", SEARCH, null, "-1 year", null, null, null, null);
		validateParsedCommand("search year -1", SEARCH, null, "year -1", null, null, null, null);

		// search for workload
		validateParsedCommand("search w1", SEARCH, null, null, null, null, 1, null);
		validateParsedCommand("search w5", SEARCH, null, null, null, null, 5, null);
		validateParsedCommand("search w0", SEARCH, null, "w0", null, null, null, null);
		validateParsedCommand("search w6", SEARCH, null, "w6", null, null, null, null);
	}

	@Test
	public void testInterleavedParam() {
		// the DateTime and workload parameters can be blended into task names.
		// for DateTime phrases, the words cannot be spread out across the names. they must be present together as a subsetence
		validateParsedCommand("add do tomorrow CS3230 w3 tutorial", ADD, null, "do CS3230 tutorial", "tomorrow", "tomorrow", 3, null);
		validateParsedCommand("add attend w4 meeting tomorrow 4pm to 5pm at office", ADD, null, "attend meeting at office", "tomorrow 4pm", "tomorrow 5pm", 4, null);
		validateParsedCommand("add start 9am to 10pm next week revising for finals w5", ADD, null, "start revising for finals", "next week 9am", "next week 10pm", 5, null);
	}

	@Test
	public void testDoubleQuotesEscape() {
		// using double quotes as an escape for DateTime
		validateParsedCommand("add watch \"the day after tomorrow\" day after tomorrow", ADD, null, "watch the day after tomorrow", "day after tomorrow", "day after tomorrow", null, null);
		validateParsedCommand("add \"April Fools\" w2 12am 1 April", ADD, null, "April Fools", "12am 1 April", "12am 1 April", 2, null);
		validateParsedCommand("add w5 \"Chrismas\" Dinner  1800h to 1900h Christmas", ADD, null, "Chrismas Dinner", "1800h Christmas", "1900h Christmas", 5, null);

		// using two double quotes to record single double quotes
		validateParsedCommand("add Remember the date: \"\"13 April\"\" 13 April", ADD, null, "Remember the date: \"13 April\"", "13 April", "13 April", null, null);
		
		// using double quotes as an escape for workload
		validateParsedCommand("add \"w1\" w1", ADD, null, "w1", null, null, 1, null);
		validateParsedCommand("add \"w0\" w0", ADD, null, "w0 w0", null, null, null, null);
		
		// search
		validateParsedCommand("search looking for a \"day\"", SEARCH, null, "looking for a day", null, null, null, null);
		validateParsedCommand("search looking for \"\"a few quoted words\"\"", SEARCH, null, "looking for \"a few quoted words\"", null, null, null, null);
	}

	private void validateAddSingleDateTime(String dt) {
		validateParsedCommand(ADD + " " + TEST_NAME + " " + dt, ADD, null, TEST_NAME, dt, dt, null, null);
		validateParsedCommand(ADD  + " "+ dt + " " + TEST_NAME, ADD, null, TEST_NAME, dt, dt, null, null);
	}

	private void validateAddNameWorkLoad(String name, int workload) {
		assert(workload > 0 && workload < 6);
		String workloadString = "w"+workload;
		validateParsedCommand(ADD + " " + name + " " + workloadString, ADD, null, name, null, null, workload, null);
		validateParsedCommand(ADD + " " + workloadString + " " + name, ADD, null, name, null, null, workload, null);
	}

	private void validateAddNameSingleDateTimeWorkload(String name, String dateTime, int workload) {
		String workloadString = "w"+workload;
		validateParsedCommand(ADD + " " + name + " " + dateTime + " " + workloadString, ADD, null, name, dateTime, dateTime, workload, null);
		validateParsedCommand(ADD + " " + name + " " + workloadString + " " + dateTime, ADD, null, name, dateTime, dateTime, workload, null);
		validateParsedCommand(ADD + " " + workloadString + " " + name + " " + dateTime, ADD, null, name, dateTime, dateTime, workload, null);
		validateParsedCommand(ADD + " " + workloadString + " " + dateTime + " " + name, ADD, null, name, dateTime, dateTime, workload, null);
		validateParsedCommand(ADD + " " + dateTime + " " + name + " " + workloadString, ADD, null, name, dateTime, dateTime, workload, null);
		validateParsedCommand(ADD + " " + dateTime + " " + workloadString + " " + name, ADD, null, name, dateTime, dateTime, workload, null);
	}

	private void validateAddNameTimedWorkload(String name, String range, String startTime, String endTime, int workload) {
		String workloadString = "w"+workload;
		validateParsedCommand(ADD + " " + name + " " + range + " " + workloadString, ADD, null, name, startTime, endTime, workload, null);
		validateParsedCommand(ADD + " " + name + " " + workloadString + " " + range, ADD, null, name, startTime, endTime, workload, null);
		validateParsedCommand(ADD + " " + workloadString + " " + name + " " + range, ADD, null, name, startTime, endTime, workload, null);
		validateParsedCommand(ADD + " " + workloadString + " " + range + " " + name, ADD, null, name, startTime, endTime, workload, null);
		validateParsedCommand(ADD + " " + range + " " + name + " " + workloadString, ADD, null, name, startTime, endTime, workload, null);
		validateParsedCommand(ADD + " " + range + " " + workloadString + " " + name, ADD, null, name, startTime, endTime, workload, null);
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\parser\ParserTest.java





