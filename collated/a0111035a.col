//@author: a0111035a



	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\database\core\LogicRequest.java
	 */

package com.nexus.simplify.database.core;

import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nexus.simplify.logic.usercommand.OperationType;
import com.nexus.simplify.logic.usercommand.ParameterType;

/**
 * Helper class for testing purposes. Allows to track the method and parameters that
 * Logic calls on Database
 * 
 *  */
public class LogicRequest {
	OperationType _operation;
	Object[] _parameter;
	OperationType _displayOp = OperationType.DISPLAY;
	OperationType _addOp = OperationType.ADD;
	OperationType _modifyOp = OperationType.MODIFY;
	OperationType _deleteOp = OperationType.DELETE;
	OperationType _doneOp = OperationType.DONE;
	OperationType _clearOp = OperationType.CLEAR;
	OperationType _undoOp = OperationType.UNDO;
	OperationType _searchOp = OperationType.SEARCH;
	OperationType _invalidOp = OperationType.INVALID;
	Logger LOGGER = LoggerFactory.getLogger(LogicRequest.class.getName());
	
	public LogicRequest() {
		_operation = OperationType.INVALID;
		_parameter = new Object[ParameterType.MAX_SIZE];
	}
	
	public void reset() {
		_operation = OperationType.INVALID;
		_parameter = new Object[ParameterType.MAX_SIZE];
	}

	/**
	 * Track the parameter called onto addTimedTask in Database
	 * 
	 * @param name name of task
	 * @param startTime time and date when task starts
	 * @param endTime time and date when task ends
	 * @param workload amount of effort to be put into the task from a range of 1 - 5
	 */
	public void addTimedTask(String name, Date startTime, Date endTime, int workload) {
		LOGGER.info("addTimedTasked is called. Name: {}, StartTime: {}, EndTime: {}, Workload: {}",
				name, startTime, endTime, workload);
		setOperationType(_addOp);
		setName(name);
		setStartTime(startTime);
		setEndTime(endTime);
		setWorkload(workload);
	}
	
	/**
	 * Track the parameter called onto addDeadlineTask in Database.
	 * 
	 * @param name name of task
	 * @param deadline time and date when task ends
	 * @param workload amount of effort to be put into the task from a range of 1 - 5
	 * 
	 */
	public void addDeadlineTask(String name, Date deadline, int workload) {
		LOGGER.info("addDeadlineTask is called. Name: {}, Deadline: {}, Workload: {}",
				name, deadline, workload);
		setOperationType(_addOp);
		setName(name);
		setStartTime(deadline);
		setEndTime(deadline);
		setWorkload(workload);
	}
	
	/**
	 * Track the parameter called onto addGenericTask in Database.
	 * 
	 * @param name name of task
	 * @param workload amount of effort to be put into the task from a range of 1 - 5
	 *
	 */
	public void addGenericTask(String name, int workload) {
		LOGGER.info("addGenericTask is called. Name: {}, Workload: {}",
				name, workload);
		setOperationType(_addOp);
		setName(name);
		setWorkload(workload);
	}
	
	/**
	 * Track the parameter called onto deleteTaskByIndex() in Database.
	 * 
	 * @param index index of task with respect to the billboard
	 * @throws IndexOutOfBoundsException if index is not within range of 1 - 15 inclusive.
	 * 
	 */
	public void deleteTaskByIndex(int index) {
		LOGGER.info("deleteTaskByIndex is called. Index: {}", index);
		setOperationType(_deleteOp);
		setIndex(index);
	}
	
	/**
	 * Track the parameter called onto clearContent in Database.
	 */
	public void clearContent() {
		LOGGER.info("clearContent is called.");
		setOperationType(_clearOp);
	}
	
	// Not implemented yet
//	public void searchDatabase(String[] parameter, boolean[] searchField) {
//		setOperationType(_searchOp);
//	}
	
	// Not implemented yet
//	/**
//	 * Track the parameter called onto toggleDisplay in Database.
//	 * 
//	 * @param option toggles the sorting order of the task lists
//	 * */
//	public void toggleDisplay(String option) {
//		setOperationType(_displayOp);
//	}
	
	/**
	 * Track the parameter called onto modifyName in Database.
	 * 
	 * @param index index of task with respect to the billboard
	 * @param newName new name to be written to the task
	 *  
	 * */
	public void modifyName(int index, String newName) {
		LOGGER.info("modifyName is called. Index: {}, Name: {}", index, newName);
		setOperationType(_modifyOp);
		setIndex(index);
		setName(newName);
	}
	
	/**
	 * Track the parameter called onto modifyWorkload in Database.
	 * 
	 * @param index index of task with respect to the billboard
	 * @param newWorkloadValue new value of workload to be written to the task
	 *
	 * */
	public void modifyWorkload(int index, int newWorkloadValue) {
		LOGGER.info("modifyWorkload is called. Index: {}, Workload: {}", index, newWorkloadValue);
		setOperationType(_modifyOp);
		setIndex(index);
		setWorkload(newWorkloadValue);
	}
	
	/**
	 * Track the parameter called onto modifyStartTime in Database.
	 *  
	 * @param index index of task with respect to the billboard
	 * @param newStartTime new value of start time to be written to the task
	 * @param newEndTime new value of end time to be written to the task
	 * @throws Exception if the start time is later than the end time
	 * */
	public void modifyStartEnd(int index, Date newStartTime, Date newEndTime) throws Exception {
		LOGGER.info("modifyStartTime is called. Index: {}, StartTime: {}, EndTime: {}", index, newStartTime, newEndTime);
		setOperationType(_modifyOp);
		setIndex(index);
		setStartTime(newStartTime);
		setEndTime(newEndTime);
	}
	
	/**
	 * Track the parameter called onto markTaskDone in Database.
	 * 
	 */
	public void markTaskDone(int indexToMarkDone) {
		LOGGER.info("markTaskDone is called. Index: {}", indexToMarkDone);
		setOperationType(_doneOp);
	}
	
	// check if there is missing backslash
	public void modifyFileLocation(String newFileLocation) {
		setOperationType(_modifyOp);
		setFileLocation(newFileLocation);
	}

	
	// Getters and Setters
	
	public void setOperationType(OperationType op) {
		_operation = op;
	}
	
	public void setIndex(int index) {
		_parameter[ParameterType.INDEX_POS] = index;
	}
	
	public void setName(String name) {
		_parameter[ParameterType.NEW_NAME_POS] = name;
	}
	public void setStartTime(Date startTime) {
		_parameter[ParameterType.NEW_STARTTIME_POS] = startTime;
	}
	public void setEndTime(Date endTime) {
		_parameter[ParameterType.NEW_ENDTIME_POS] = endTime;
	}
	public void setWorkload(int workload) {
		_parameter[ParameterType.NEW_WORKLOAD_POS] = workload;
	}
	public void setFileLocation(String fileLocation) {
		_parameter[ParameterType.NEW_FILELOCATION_POS] = fileLocation;
	}
	
	public OperationType getOperationType(){
		return _operation;
	}

	public Object[] getParameter(){
		return _parameter;
	}

	public Object getIndex() {
		if (_parameter[ParameterType.INDEX_POS] == null) {
			return null;
		} else {
			int index = (int) _parameter[ParameterType.INDEX_POS];
			return index;
		}
		
	}
	
	public String getName() {
		String index = (String) _parameter[ParameterType.NEW_NAME_POS];
		return index;
	}
	
	public Date getStartTime() {
		Date startTime = (Date) _parameter[ParameterType.NEW_STARTTIME_POS];
		return startTime;
	}
	
	public Date getEndTime() {
		Date endTime = (Date) _parameter[ParameterType.NEW_ENDTIME_POS];
		return endTime;
	}
	
	public int getWorkload() {
		if (_parameter[ParameterType.NEW_WORKLOAD_POS] == null) {
			return 0;
		} else {
			int workload = (int) _parameter[ParameterType.NEW_WORKLOAD_POS];
			return workload;
		}
		
	}
	
	public String getFileLocation() {
		String fileLocation = (String) _parameter[ParameterType.NEW_FILELOCATION_POS];
		return fileLocation;
	}	
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\database\core\LogicRequest.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\database\tasktype\DeadlineTask.java
	 */

	/**
	 * Returns an exact copy of the task.
	 * */
	public DeadlineTask getCopy() {
		StringProperty cName = new SimpleStringProperty(getName());
		IntegerProperty cWorkload = new SimpleIntegerProperty(getWorkload());
		StringProperty cID = new SimpleStringProperty(getId());
		DateTime cDeadline = getDeadline();
		DeadlineTask copy = new DeadlineTask(cName, cDeadline, cWorkload, cID);
		return copy;
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\database\tasktype\DeadlineTask.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\api\IParser.java
	 */


package com.nexus.simplify.parser.api;

import com.nexus.simplify.logic.usercommand.UserCommand;

/**
 * Interface class for facade of Parser component.
 * 
 */
public interface IParser {
	/**
	 * Returns the the user's command in terms of the operation type and parameters specified.
	 * 
	 * @param userInput		User command string.
	 * @return 				Operation type and parameters specified.
	 * @throws Exception 	When user input fail to parse.
	 */
	public UserCommand parseInput(String userInput) throws Exception;
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\api\IParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\api\Parser.java
	 */


package com.nexus.simplify.parser.api;

import java.io.BufferedReader;
import java.io.InputStreamReader;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nexus.simplify.logic.usercommand.UserCommand;
import com.nexus.simplify.parser.core.CoreParser;
import com.nexus.simplify.parser.data.CommandData;
import com.nexus.simplify.parser.tokeniser.Tokeniser;

/**
 * A facade to facilitate interaction between Parser component with other
 * components.
 * 
 * The coding style was used as a guide for all code in Parser component. It can
 * be found in the link below. Coding Style: {@link https
 * ://docs.google.com/a/nuscomputing.com/document/pub?id=1
 * iAESIXM0zSxEa5OY7dFURam_SgLiSMhPQtU0drQagrs&amp}
 * 
 */

public class Parser implements IParser {
	private static final String ERROR_PARSING__COMMAND = "Error parsing command: %1$s. "
			+ "/n" + "Please specify parameters as clear as possible";

	private static final String LOG_USER_INPUT = "Parsing user input: {}";

	private static Logger LOGGER = LoggerFactory.getLogger(CoreParser.class.getName());
	private static String _input;
	private static Tokeniser _tokeniser = new Tokeniser();
	private static CoreParser _parser = new CoreParser();
	private static CommandData _commandData = CommandData.getInstance();
	private static String[] _userTokens;

	/**
	 * Takes in user string input and returns corresponding requested operation
	 * and given parameters stored in UserCommand
	 */
	@Override
	public UserCommand parseInput(String userInput) throws Exception {
		try {
			_input = userInput;
			LOGGER.info(LOG_USER_INPUT, _input);
			_userTokens = _tokeniser.tokenise(_input);
			_parser.parseTokens(_userTokens);

			// The individual parser classes update the commandData singleton
			// with the operation and parameters
			UserCommand userCommand = _commandData.createCommand();

			return userCommand;
		} catch (Exception e) {
			throw new Exception(String.format(ERROR_PARSING__COMMAND, _input));
		}
	}

	/**
	 * Returns user input string that was given to Parser object through
	 * {@link parseInput}
	 * 
	 * 
	 * @return User Input String
	 * 
	 */
	public String getGivenInput() {
		return _input;
	}

	// main function to run white-box texting with console input
	public static void main(String[] args) {
		InputStreamReader inStream = new InputStreamReader(System.in);
		BufferedReader br = new java.io.BufferedReader(inStream);
		Parser test = new Parser();
		while (true) {
			try {
				test.parseInput(br.readLine());
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\api\Parser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\CoreParser.java
	 */


package com.nexus.simplify.parser.core;

public class CoreParser extends TokenParser {
	private static OperationParser _opParser = new OperationParser();
	private static ParamParser _paramParser = new ParamParser();

	final String MESSAGE_UNPARSED_TOKENS = "Unparsed tokens detected: %1$s";

	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		tokenList = _opParser.parseTokens(tokenList);
		tokenList = _paramParser.parseTokens(tokenList);

		// There should not be remaining unidentified tokens who are not
		// recognised as operation or parameters
		if (!isTokenListEmpty(tokenList)) {
			throw new Exception(appendStringArr(MESSAGE_UNPARSED_TOKENS,
					tokenList));
		}
		return tokenList;
	}

	private String appendStringArr(String string, String[] stringArr) {
		String newString = string;
		for (String str : stringArr) {
			string += " " + str;
		}
		return newString;
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\CoreParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\DateTimeParser.java
	 */


package com.nexus.simplify.parser.core;

import java.util.Date;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nexus.simplify.logic.usercommand.OperationType;
import com.nexus.simplify.parser.data.CommandData;
import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

/**
 * 
 * 
 * This DateTime parser relies heavily on Natty library @
 * http://natty.joestelmach.com}
 *
 */
public class DateTimeParser extends TokenParser {

	private static final int MIN_NUMBER_OF_DATEGROUP = 0;
	private static final int MAX_NUMBER_OF_DATEGROUP = 1;
	private static final int MAX_NUMBER_OF_DATETIME = 2;
	private static final int SIZE_OF_SINGLE_DATETIME = 1;
	private static final int SIZE_OF_RANGED_DATETIME = 2;

	private static final String ERROR_TOO_MANY_TEMPORAL_ELEMENTS = "Too many groups of temporal elements provided.";
	private static final String ERROR_TOO_MANY_TEMPORAL_ELEMENTS_TIMERANGE = "Too many temporal elements in specifed time range";
	private static final String ERROR_PARTIAL_TOKEN_NOT_FOUND = "Partial token given is not found in the provided token list";
	private static final String LOG_NATTY_STRING_PARSED = "String parsed by natty: {}";

	private static final String REGEX_ONE_OR_MORE_WHITESPACE = "\\s+";

	private static final Logger LOGGER = LoggerFactory
			.getLogger(DateTimeParser.class.getName());
	private static final CommandData _commandData = CommandData.getInstance();

	// Key strings to search for in user input parse tree
	// Used to identify what aspect of time the user is searching for
	private final String YEAR = "YEAR_OF";
	private final String MONTH = "MONTH_OF_YEAR";
	private final String DAY_OF_MONTH = "DAY_OF_MONTH";
	private final String DAY_OF_WEEK = "DAY_OF_WEEK";
	private final String HOURS = "HOURS_OF_DAY";

	private Parser natty = new Parser();

	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			String[] remainingValid = tokenList.clone();

			while (isEnclosedInDoubleQuotes(remainingValid)) {
				remainingValid = trimTokensInQuotes(remainingValid);
			}
			// Convert remaingValid tokens to string to use natty library.
			String tokenString = tokenListToStr(remainingValid);
			List<DateGroup> groupList = natty.parse(tokenString);

			// Do not proceed with parsing if no DateTime is parsed from
			// tokenString
			if (groupList.size() < 1) {
				// Natty has cornercase bug where it does not detect DateTime
				// elements that
				// follows a word containing timezone letters and IN token
				// for example, add testing 1600, where EST is a timezone and IN
				// is a valid token
				// other examples are psting 1800, cstin
				String invalidTokens = "";
				boolean retrySuccess = false;

				for (int i = 0; i < remainingValid.length; i++) {
					String string = remainingValid[i];
					groupList = natty.parse(string);
					if (groupList.size() > MIN_NUMBER_OF_DATEGROUP) {
						retrySuccess = true;
						invalidTokens = invalidTokens.trim();
						remainingValid = getRemainingTokens(invalidTokens,
								remainingValid);
						break;
					} else {
						invalidTokens += " " + remainingValid[i];
					}
				}

				if (!retrySuccess) {
					LOGGER.info("No DateTime is parsed.");
					return tokenList;
				}
			}

			// Gets a list of all dates in the only group of dates parsed.
			DateGroup dateGroup = groupList.get(0);
			List<Date> dates = groupList.get(0).getDates();
			String stringParsed = dateGroup.getText();
			LOGGER.info(LOG_NATTY_STRING_PARSED, stringParsed);

			// Ensure that we proceed setting time elements for fully parsed
			// words.
			// This is because Natty will try to guess the date and time for
			// tokens that "appear" to be valid
			// We do not second guess the user's input. If an entire word is not
			// parsed by natty, we reject it as a DateTime element
			while (!isParsedValid(stringParsed, remainingValid)) {
				// need retrieve the actual correct stringParsed variable
				String misparsedToken = findFullToken(stringParsed,
						remainingValid);
				remainingValid = getRemainingTokens(misparsedToken,
						remainingValid);
				String remainingString = tokenListToStr(remainingValid);
				groupList = natty.parse(remainingString);
				if (groupList.size() < 1) {
					// no actual correct DateTime token is found
					LOGGER.info("No valid DateTime token is found");
					return tokenList;
				}
				dateGroup = groupList.get(0);
				stringParsed = dateGroup.getText();
				dates = dateGroup.getDates();

			}

			// Proceed with parsing of DateTime...

			// Throw exception when user includes too many groups of dates.
			// e.g ... from 03/04 to 03/05 starting tomorrow
			if (groupList.size() > MAX_NUMBER_OF_DATEGROUP) {
				throw new Exception(ERROR_TOO_MANY_TEMPORAL_ELEMENTS);
				// Throw exception when user input a range with too many
				// temporal elements
				// e.g ... from 03/04 to 03/05 to 03/06
			} else if (dates.size() > MAX_NUMBER_OF_DATETIME) {
				throw new Exception(ERROR_TOO_MANY_TEMPORAL_ELEMENTS_TIMERANGE);
			} else {
				// Finally, depending on the operation, we process the dates
				// (which should be the correct by now...)
				if (dates.size() == SIZE_OF_SINGLE_DATETIME) {
					// DateTime parsing for search
					if (_commandData.getUserOp() == OperationType.SEARCH) {
						// natty does not support user specifying the year only
						// we have to support simple "search year XXXX" and
						// "search XXXX year"
						if (containsYear(tokenList)) {
							doSearchYear(stringParsed);
							// add "year" to list of used tokens
							stringParsed += " " + "year";
						} else {
							doSearchDateTime(dateGroup);
						}
					} else {
						// Parsing single non-search DateTime.
						_commandData.setTime(dates.get(0).toString());
					}
				} else if (dates.size() == SIZE_OF_RANGED_DATETIME) {
					// Parsing single non-search DateTime.
					_commandData.setTime(dates.get(0).toString(), dates.get(1)
							.toString());
				}
				return getRemainingTokens(stringParsed, tokenList);
			}
		}
	}

	/**
	 * Processes the search for year values.
	 * 
	 * @param stringParsed
	 */
	private void doSearchYear(String stringParsed) {
		List<DateGroup> groupList;
		List<Date> dates;
		String yearDigits = stringParsed;
		// "1 Jan" is prefixed so that natty can parse
		// yearDigits as year value
		String forcedFormalDate = "1 Jan " + yearDigits;
		groupList = natty.parse(forcedFormalDate);
		dates = groupList.get(0).getDates();
		_commandData.setTime(dates.get(0).toString());
		_commandData.setYearSearch();
	}

	/**
	 * Processses the search for temporal search terms that appears in DateGroup
	 * syntax tree.
	 * 
	 * @param dateGroup
	 *            DateGroup of Temporal search terms.
	 * @param dates
	 */
	private void doSearchDateTime(DateGroup dateGroup) {
		// By searching the syntax tree produced by natty
		// parser, we can identity what kind
		// of date or time was explicitly specified by the
		// user
		String syntaxTree = dateGroup.getSyntaxTree().toStringTree();
		List<Date> dates = dateGroup.getDates();

		if (syntaxTree.contains(YEAR)) {
			_commandData.setTime(dates.get(0).toString());
			_commandData.setYearSearch();
		}

		if (syntaxTree.contains(MONTH)) {
			_commandData.setTime(dates.get(0).toString());
			_commandData.setMonthSearch();
		}

		if (syntaxTree.contains(DAY_OF_MONTH)) {
			_commandData.setTime(dates.get(0).toString());
			_commandData.setDayOfMonthSearch();
		}

		if (syntaxTree.contains(DAY_OF_WEEK)) {
			_commandData.setTime(dates.get(0).toString());
			_commandData.setDayOfWeekSearch();
		}

		if (syntaxTree.contains(HOURS)) {
			_commandData.setTime(dates.get(0).toString());
			_commandData.setHourSearch();
		}
	}

	/**
	 * Return false if natty parser parsed a word partially. E.g "CS3230" is
	 * parsed into "230"
	 * 
	 * @param stringParsed
	 * @param tokenList
	 * @return
	 */
	protected boolean isParsedValid(String stringParsed, String[] tokenList) {
		String[] parsedArray = stringParsed.split(REGEX_ONE_OR_MORE_WHITESPACE);
		boolean found = false;

		for (int i = 0; i < parsedArray.length; i++) {
			for (int j = 0; j < tokenList.length; j++) {
				found = false;

				if (parsedArray[i].equals(tokenList[j])) {
					found = true;
					break;
				}
			}

			if (found) {
				continue;
			} else {
				return false;
			}
		}
		return found;
	}

	/**
	 * Return the full word of a partial word. This is a helper function used
	 * when natty parsed a partial word.
	 * 
	 * @param partialToken
	 *            A substring of a token from tokenList parsed by natty.
	 * @param tokenList
	 *            List of tokens containing partialToken.
	 * @return Full token containing partialToken
	 * @throws Exception
	 *             Exception occurs when partialTokens is not found in
	 *             tokenList.
	 */
	protected String findFullToken(String partialTokens, String[] tokenList)
			throws Exception {
		String[] partialArray = partialTokens.trim().split(
				REGEX_ONE_OR_MORE_WHITESPACE);

		for (int i = 0; i < tokenList.length; i++) {
			for (int j = 0; j < partialArray.length; j++) {
				String currentToken = tokenList[i];
				String currentPartial = partialArray[j];
				if (currentToken.equals(currentPartial)) {
					continue;
				} else if (currentToken.contains(currentPartial)) {
					return currentToken;
				}
			}
		}

		LOGGER.warn("findFullToken failed on {} and {}", partialTokens,
				tokenList);

		throw new Exception(ERROR_PARTIAL_TOKEN_NOT_FOUND);
	}

	/**
	 * getRemainingTokens method for DateTimeParser is modified to ignore tokens
	 * enclosed in double quotation marks.
	 * 
	 * @param tokenList
	 *            List of tokens.
	 * @return tokenList with tokens in usedTokens removed, ignoring tokens
	 *         between double quotation marks.
	 */
	@Override
	protected String[] getRemainingTokens(String usedTokens, String[] tokenList) {
		// Specified token list cannot be a null object, else there is nothing
		// to remove tokens from.
		assert (usedTokens != null);

		if (usedTokens.equals("")) {
			return tokenList;
		}

		String[] usedTokenList = strToTokenList(usedTokens);
		// You cannot use up more tokens than it is provided.
		assert (usedTokenList.length <= tokenList.length);

		String[] newTokenList = new String[tokenList.length
				- usedTokenList.length];
		String[] tempTokenList = replaceTokensWithNullIgnoreQuotes(tokenList,
				usedTokenList);
		String[] remainingTokens = removeNullTokens(newTokenList, tempTokenList);
		return remainingTokens;
	}

	/**
	 * Clones the specified token list and replacing tokens found in used token
	 * list with {@code null}. Ignores tokens enclosed in double quotes.
	 * 
	 * @param tokenList
	 * @param usedTokenList
	 * @return
	 */
	private String[] replaceTokensWithNullIgnoreQuotes(String[] tokenList,
			String[] usedTokenList) {
		String[] tempTokenList = tokenList.clone();
		boolean ignoreToken = false;

		for (int i = 0; i < tempTokenList.length; i++) {
			String currentUserToken = tempTokenList[i];

			// case where single word within double quotes
			if (currentUserToken.charAt(0) == DOUBLE_QUOTE
					&& currentUserToken.charAt(currentUserToken.length() - 1) == DOUBLE_QUOTE) {
				continue;
			}

			// case where single word within double quotes
			if (currentUserToken.charAt(0) == DOUBLE_QUOTE
					|| currentUserToken.charAt(currentUserToken.length() - 1) == DOUBLE_QUOTE) {
				ignoreToken = !ignoreToken;
			}

			if (!ignoreToken) {

				for (int j = 0; j < usedTokenList.length; j++) {
					if (usedTokenList[j].equals(tempTokenList[i])) {
						tempTokenList[i] = null;
					}
				}
			}
		}
		return tempTokenList;
	}

	/**
	 * A helper function for search operation. Searches for a "year" (ignore
	 * case) token and change that token to lower case.
	 * 
	 * @param tokenList
	 *            List of tokens.
	 * @return {@code true} if tokenList contains "year" (ignore case).
	 */
	private boolean containsYear(String[] tokenList) {
		final String year = "year";

		for (int i = 0; i < tokenList.length; i++) {
			String string = tokenList[i];
			if (string.equalsIgnoreCase(year)) {
				tokenList[i] = year;
				return true;
			}
		}
		return false;
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\DateTimeParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\DisplayParser.java
	 */


package com.nexus.simplify.parser.core;

import com.nexus.simplify.parser.data.CommandData;

/**
 * Parses display preference string. This parser is called immediately when
 * display command is parsed.
 * 
 *
 */
public class DisplayParser extends TokenParser {
	CommandData commandData = CommandData.getInstance();

	/**
	 * Parses tokenList for display preference string.
	 */
	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			String displayPref = tokenList[0];
			commandData.setDisplay(displayPref);
			return getRemainingTokens(displayPref, tokenList);
		}

	}

}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\DisplayParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\FileLocationParser.java
	 */


package com.nexus.simplify.parser.core;

import com.nexus.simplify.parser.data.CommandData;

public class FileLocationParser extends TokenParser {
	String usedTokens;
	CommandData commandData = CommandData.getInstance();
	String id;
	String filePathString;

	/**
	 * Parses tokenList for filelocation tokens.
	 */
	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			id = tokenList[0];
			if (id.equalsIgnoreCase("filelocation")
					|| id.equalsIgnoreCase("file location")) {
				filePathString = tokenList[1];
				commandData.setFileLocation(filePathString);

				usedTokens = tokenList[0] + " " + tokenList[1];
				return getRemainingTokens(usedTokens, tokenList);
			}
			return tokenList;
		}
	}

}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\FileLocationParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\IndexParser.java
	 */


package com.nexus.simplify.parser.core;

import com.nexus.simplify.parser.data.CommandData;

public class IndexParser extends TokenParser {
	CommandData commandData = CommandData.getInstance();

	/**
	 * Parses tokenList for index tokens.
	 */
	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			String index = tokenList[0];
			if (index.matches("[0-9]+")) {
				commandData.setTaskIndex(index);
				return getRemainingTokens(index, tokenList);
			}
			return tokenList;
		}
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\IndexParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\NameParser.java
	 */


package com.nexus.simplify.parser.core;

import com.nexus.simplify.parser.data.CommandData;

/**
 * Parsing of name works by parsing the remaining tokens as new task name after
 * all other parameters had been parsed.
 *
 */
public class NameParser extends TokenParser {
	CommandData commandData = CommandData.getInstance();

	/**
	 * Parses remaining tokens in tokenList as name tokens.
	 */
	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			if (isEnclosedInDoubleQuotes(tokenList)) {
				tokenList = trimQuotesInTokens(tokenList);
			}
			String name = tokenListToStr(tokenList);
			commandData.setNewName(name);
			return getRemainingTokens(name, tokenList);
		}
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\NameParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\OperationParser.java
	 */


package com.nexus.simplify.parser.core;

import com.nexus.simplify.logic.usercommand.OperationType;
import com.nexus.simplify.parser.data.CommandData;

public class OperationParser extends TokenParser {
	private static final CommandData commandData = CommandData.getInstance();
	private static final DisplayParser displayParser = new DisplayParser();
	private static final IndexParser indexParser = new IndexParser();
	private static final FileLocationParser fileLocationParser = new FileLocationParser();
	/**
	 * Parses tokenList for operation tokens.
	 */
	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			String opString = tokenList[0].toLowerCase();
			tokenList[0] = opString;
			OperationType userOp = commandData.getOperationType(opString);

			// Implement adding of task without providing keywords for add e.g
			// "add"
			if (userOp == OperationType.INVALID) {
				userOp = OperationType.ADD;
				opString = "";
			}

			String[] remainingTokens = getRemainingTokens(opString, tokenList);
			remainingTokens = switchUserOperation(userOp, remainingTokens);
			return remainingTokens;
		}
	}

	/**
	 * Switch case statements for user specified operation. Remove used
	 * operation token from remainingTokens
	 * 
	 * @param userOp			User specified operation token.
	 * @param remainingTokens	List of remaining tokens to be parsed.
	 * @return					List of remaining tokens with userOp remove.
	 * @throws Exception		When parsing of specified token list fails. 
	 */
	private String[] switchUserOperation(OperationType userOp,
										String[] remainingTokens) throws Exception {
		// Handle commands that have special first parameters
		switch (userOp) {
			case DISPLAY:
				commandData.setOp(userOp);
				return displayParser.parseTokens(remainingTokens);
	
			case MODIFY:
				commandData.setOp(userOp);
				String[] postIndexParseTokens = indexParser
						.parseTokens(remainingTokens);
				if (postIndexParseTokens.equals(remainingTokens)) {
					return fileLocationParser.parseTokens(remainingTokens);
				} else {
					return postIndexParseTokens;
				}
	
			case DONE:
				commandData.setOp(userOp);
				return indexParser.parseTokens(remainingTokens);
	
			case DELETE:
				commandData.setOp(userOp);
				return indexParser.parseTokens(remainingTokens);
	
			default:
				commandData.setOp(userOp);
				return remainingTokens;
		}
	}
}
	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\OperationParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\ParamParser.java
	 */


package com.nexus.simplify.parser.core;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ParamParser extends TokenParser {
	private static final DateTimeParser dtParser = new DateTimeParser();
	private static final WorkloadParser wlParser = new WorkloadParser();
	private static final NameParser nameParser = new NameParser();
	private static final Logger LOGGER = LoggerFactory
			.getLogger(CoreParser.class.getName());

	private static final String LOG_PASRING_ERROR = "Parse Error on: {}";

	/**
	 * Parses unused tokens in tokenList for all parameters types.
	 */
	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			try {
				// Parse DateTime tokens.
				tokenList = dtParser.parseTokens(tokenList);

				// Parse workload tokens.
				tokenList = wlParser.parseTokens(tokenList);

				// Remaining tokens are taken to be new name as it is the last
				// type of supported parameters
				tokenList = nameParser.parseTokens(tokenList);
				return tokenList;
			} catch (Exception e) {
				LOGGER.error(LOG_PASRING_ERROR, tokenList, e);
				throw e;
			}
		}

	}

}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\ParamParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\TokenParser.java
	 */


package com.nexus.simplify.parser.core;

/**
 * An abstract class to generalise the role of token parsers in Parser
 * component. TokenParser contains many useful methods that parsers might need
 * while they parse for specific type of tokens
 *
 */
public abstract class TokenParser {
	// Char value of double quote ("), used for detection in tokens
	protected final char DOUBLE_QUOTE = 34;

	private final int ARRAY_EMPTY_SIZE = 0;
	private final String EMPTY_TOKEN = "";

	/**
	 * Takes a list of tokens and process the tokens that it is able to parse.
	 * 
	 * @param tokenList
	 *            List of tokens to be parsed.
	 * @return List of remaining tokens that were not used.
	 * @throws Exception
	 *             When parsing of specified token list fails.
	 */
	public abstract String[] parseTokens(String[] tokenList) throws Exception;

	/**
	 * Returns a list of tokens with all tokens in usedTokens removed.
	 * 
	 * @param usedTokens	List of tokens to be removed.
	 * @param tokenList		List of tokens containing usedTokens.
	 * @return				List of tokens with tokens in usedTokens removed.
	 */
	protected String[] getRemainingTokens(String usedTokens, String[] tokenList) {
		// Specified token list cannot be a null object, else there is nothing
		// to remove tokens from.
		assert (usedTokens != null);

		if (usedTokens.equals(EMPTY_TOKEN)) {
			return tokenList;
		}

		String[] usedTokenList = strToTokenList(usedTokens);
		// You cannot use up more tokens than it is provided.
		assert (usedTokenList.length <= tokenList.length);

		String[] newTokenList = new String[tokenList.length
				- usedTokenList.length];
		String[] tempTokenList = replaceTokensWithNull(tokenList, usedTokenList);
		String[] remainingTokens = removeNullTokens(newTokenList, tempTokenList);
		return remainingTokens;
	}

	/**
	 * Return {@code true} if the specified array contains {@code null} element.
	 * 
	 * @param tokenList
	 *            Token list to be checked for {@code null} element.
	 * @return {@code true} if token list contains null element, {@code false}
	 *         if otherwise.
	 */
	protected boolean hasNull(String[] tokenList) {
		for (int i = 0; i < tokenList.length; i++) {
			String string = tokenList[i];
			if (string == null) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Transfer non-null elements from oldTokenList to newTokenList. Length of
	 * newTokenList specified must be exactly the same with number of non-null
	 * elements.
	 * 
	 * @param newTokenList
	 *            New empty token that has the length of non {@code null}
	 *            elements in oldTokenList.
	 * @param oldTokenList
	 *            List of tokens with {@code null} elements.
	 * @return New token list that is fully filled with tokens.
	 */
	protected String[] removeNullTokens(String[] newTokenList,
										String[] oldTokenList) {
		// Populate newTokenList with remaining unused tokens.
		if (newTokenList.length == ARRAY_EMPTY_SIZE) {
			return newTokenList;
		} else {
			int count = 0;

			for (int i = 0; i < oldTokenList.length; i++) {
				if (oldTokenList[i] != null) {
					newTokenList[count] = oldTokenList[i];
					count++;
				}
			}

			// New list should be fully filled. Presence of null suggests that
			// more than one remaining token was not brought over
			assert (!hasNull(newTokenList));
			return newTokenList;
		}
	}

	/**
	 * Clones the specified token list and replacing tokens found in used token
	 * list with {@code null}.
	 * 
	 * @param tokenList
	 *            List of tokens to remove tokens from.
	 * @param usedTokenList
	 *            List of tokens to be removed.
	 * @return tokenList with used tokens filled with {@code null}.
	 */
	protected String[] replaceTokensWithNull(String[] tokenList,
											String[] usedTokenList) {
		String[] tempTokenList = tokenList.clone();

		for (int i = 0; i < tempTokenList.length; i++) {
			for (int j = 0; j < usedTokenList.length; j++) {
				if (usedTokenList[j].equals(tempTokenList[i])) {
					tempTokenList[i] = null;
				}
			}
		}
		return tempTokenList;
	}

	/**
	 * Returns {@code true} if specified tokenList contains at least one token
	 * enclosed in double quotations.
	 * 
	 * @param tokenList
	 *            List of tokens.
	 * @return {@code true} if tokenList contains at least one token enclosed in
	 *         double quotations, otherwise {@code false}.
	 */
	protected boolean isEnclosedInDoubleQuotes(String[] tokenList) {
		boolean first = false;
		boolean second = false;
		String[] temp = tokenList.clone();

		// Search for a pair of quotation marks in the whole array
		for (int i = 0; i < temp.length; i++) {
			String string = temp[i];
			final int startOfString = 0;
			final int endOfString = string.length() - 1;

			if (string.charAt(startOfString) == DOUBLE_QUOTE) {
				first = true;
			}

			if (first && string.charAt(endOfString) == DOUBLE_QUOTE) {
				second = true;
			}
		}
		return first && second;
	}

	/**
	 * Removes words enclosed in a pair of double quotation marks from a token
	 * array.
	 * 
	 * @param tokenList
	 *            List of tokens to be trimmed.
	 * @return tokenList without words enclosed in a pair of double quotation
	 *         marks.
	 */
	protected String[] trimTokensInQuotes(String[] tokenList) {
		String[] temp = tokenList.clone();
		int start = -1;
		int end = -1;

		for (int i = 0; i < temp.length; i++) {
			String string = temp[i];
			final int startOfString = 0;
			final int endOfString = string.length() - 1;

			if (string.charAt(startOfString) == DOUBLE_QUOTE) {
				start = i;
			}

			if (start >= 0 && string.charAt(endOfString) == DOUBLE_QUOTE) {
				end = i;
			}
		}

		int lengthOfTrimmed = (end - start + 1);
		String[] remaining = new String[temp.length - lengthOfTrimmed];

		// keep partition that is left of trimmed
		for (int i = 0; i < start; i++) {
			remaining[i] = temp[i];
		}

		// keep partition that is right of trimmed
		for (int i = (end + 1); i < temp.length; i++) {
			remaining[i - lengthOfTrimmed] = temp[i];
		}
		return remaining;
	}

	/**
	 * Trims double quotation marks that encloses at least one tokens.
	 * 
	 * @param tokenList
	 *            List of tokens.
	 * @return List of tokens where no tokens are enclosed in double quotes.
	 */
	protected String[] trimQuotesInTokens(String[] tokenList) {
										String[] temp = tokenList.clone();

		for (int i = 0; i < temp.length; i++) {
			String string = temp[i];
			final int startOfString = 0;
			final int endOfString = string.length() - 1;
			final int startOfTrimmed = 1;

			if (string.charAt(startOfString) == DOUBLE_QUOTE
					&& string.charAt(endOfString) == DOUBLE_QUOTE) {
				temp[i] = string.substring(startOfTrimmed, endOfString);
			} else {
				temp[i] = string.replaceFirst("\"", EMPTY_TOKEN);
			}
		}
		return temp;
	}

	/**
	 * Returns {@true} if specified tokenList is an empty array.
	 * 
	 * @param tokenList
	 *            List of tokens.
	 * @return {@true} if specified tokenList is an empty array.
	 */
	protected boolean isTokenListEmpty(String[] tokenList) {
		// Case when all tokens are used up by the parsers
		if (tokenList.length == 0) {
			return true;
			// Case when empty string "" is entered by user
		} else if (tokenList.length == 1 & tokenList[0].equals(EMPTY_TOKEN)) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Tokenises a tokenString by splitting tokenString into substrings
	 * separated by one or more whitespaces.
	 * 
	 * @param tokenString
	 *            A string containing tokens separated by whitespaces.
	 * @return List of all tokens contained in tokenString.
	 */
	protected String[] strToTokenList(String tokenString) {
		String[] tokenList = tokenString.split("\\s+");
		return tokenList;
	}

	/**
	 * Concatenate tokens in tokenList to one long token string with tokens
	 * seperated by single whitespace.
	 * 
	 * @param tokenList
	 *            List of tokens to be concatenated.
	 * @return A long string containing all tokens in tokenList seperated by
	 *         single whitespace.
	 */
	protected String tokenListToStr(String[] tokenList) {
		StringBuilder builder = new StringBuilder();
		for (String s : tokenList) {
			builder.append(s);
			builder.append(" ");
		}
		return builder.toString().trim();
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\TokenParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\WorkloadParser.java
	 */


package com.nexus.simplify.parser.core;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nexus.simplify.parser.data.CommandData;

public class WorkloadParser extends TokenParser {
	Logger LOGGER = LoggerFactory.getLogger(WorkloadParser.class.getName());
	CommandData commandData = CommandData.getInstance();

	final int INDEX_START_OF_WORKLOAD = 1;
	

	@Override
	public String[] parseTokens(String[] tokenList) throws Exception {
		if (isTokenListEmpty(tokenList)) {
			return tokenList;
		} else {
			boolean workloadFound = false;
			String workloadString = null;
			String workloadValueString = null;
			for (int i = 0; i < tokenList.length; i++) {
				String currentToken = tokenList[i];

				if (currentToken.matches("[wW][1-5]")) {
					if (workloadFound) {
						throw new Exception("More than one workload values were present. Please specify one workload value only.");
					}
					workloadString = tokenList[i];
					workloadValueString = workloadString.substring(INDEX_START_OF_WORKLOAD);
					commandData.setWorkload(workloadValueString);
					workloadFound = true;
				}
			}
			if (workloadFound) {
				return getRemainingTokens(workloadString, tokenList);
			} else {
				return tokenList;
			}
		}

	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\core\WorkloadParser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\data\CommandData.java
	 */


package com.nexus.simplify.parser.data;

import java.util.Arrays;
import java.util.HashMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.nexus.simplify.logic.usercommand.OperationType;
import com.nexus.simplify.logic.usercommand.ParameterType;
import com.nexus.simplify.logic.usercommand.UserCommand;

/**
 * A singleton which holds data such as the user specified operation and
 * parameters from parsing of token lists generated from user command string
 * input.
 *
 */
public class CommandData {
	private static final String LOG_COMMAND_DATA = "User Operation: {}. User Parameters: {}. Search Boolean: {}";

	private static CommandData _instance = null;
	private static OperationType _userOp;
	private static String[] _paramArray;
	private static boolean[] _searchArray;
	private static HashMap<String, OperationType> _cmdHash = new HashMap<String, OperationType>();
	private static Logger LOGGER = LoggerFactory.getLogger(CommandData.class
			.getName());

	/**
	 * Returns {@code CommandData} singleton. Replaces a constructor as
	 * singletons are implemented as "static" classes. getInstance method will
	 * create a static instance of CommandData if CommandData was not
	 * instantiated.
	 * 
	 * @return The only instance of CommandData.
	 */
	public static CommandData getInstance() {
		if (_instance == null) {
			_instance = new CommandData();
		}
		return _instance;
	}

	/**
	 * Return a newly created {@link UserCommand} object which is populated with
	 * operation requested and various parameters in a string array. Parameter
	 * types that are not provided are left as {@code null}.
	 * 
	 * Stored data is reset after UserCommand is created.
	 * 
	 * @return UserCommand object with user specified operation and parameters.
	 */
	public UserCommand createCommand() {
		OperationType tempOp = _userOp;
		String[] tempParam = _paramArray.clone();
		boolean[] tempSearch = _searchArray.clone();
		_userOp = null;
		_paramArray = new String[ParameterType.MAX_SIZE];
		LOGGER.info(LOG_COMMAND_DATA, tempOp, Arrays.toString(tempParam),
				Arrays.toString(tempSearch));
		return new UserCommand(tempOp, tempParam, tempSearch);
	}

	/**
	 * Set specified operation type to class variable.
	 * 
	 * @see OperationType
	 */
	public void setOp(OperationType userOp) {
		_userOp = userOp;
	}

	/**
	 * Sets user operation type to OperationType.INVALID.
	 * 
	 * @see OperationType
	 */
	public void setInvalidOp() {
		_userOp = OperationType.INVALID;
	}

	/**
	 * Sets the specified display preference string in CommandData parameter
	 * array.
	 * 
	 * @param displayPref
	 *            The type of display action that the user wants.
	 */
	public void setDisplay(String displayPref) {
		// Logic will take display preference string from index paramater
		// position in the parameter array
		_paramArray[ParameterType.INDEX_POS] = displayPref;
	}

	/**
	 * Sets the specified task index in CommandData parameter array.
	 * 
	 * @param taskIndex
	 *            Index of a task as shown on Simplify's UI.
	 */
	public void setTaskIndex(String taskIndex) {
		_paramArray[ParameterType.INDEX_POS] = taskIndex;
	}

	/**
	 * Sets the specified task index in CommandData parameter array.
	 * 
	 * @param taskIndex
	 */
	public void setNewName(String name) {
		_paramArray[ParameterType.NEW_NAME_POS] = name;
	}

	/**
	 * Sets the specified single DateTime in CommandData parameter array.
	 * 
	 * @param time
	 *            String representation of java DateTime.
	 */
	public void setTime(String time) {
		_paramArray[ParameterType.NEW_STARTTIME_POS] = time;
		_paramArray[ParameterType.NEW_ENDTIME_POS] = time;
	}

	/**
	 * Sets the specified starting and ending DateTime in CommandData parameter
	 * array.
	 * 
	 * @param time1
	 *            String representation of starting DateTime specified by user.
	 * @param time2
	 *            String representation of ending DateTime specified by user.
	 */
	public void setTime(String time1, String time2) {
		_paramArray[ParameterType.NEW_STARTTIME_POS] = time1;
		_paramArray[ParameterType.NEW_ENDTIME_POS] = time2;
	}

	/**
	 * Sets the specified string representation of workload integer value in
	 * CommandData parameter array.
	 * 
	 * @param workload
	 *            String representation of workload integer value.
	 */
	public void setWorkload(String workload) {
		_paramArray[ParameterType.NEW_WORKLOAD_POS] = workload;
	}

	/**
	 * Sets boolean value to {@code true} to signal that the user has searched
	 * for a year value.
	 */
	public void setYearSearch() {
		_searchArray[ParameterType.SEARCH_YEAR_POS] = true;
	}

	/**
	 * Sets boolean value to {@code true} to signal that the user has searched
	 * for a month value.
	 */
	public void setMonthSearch() {
		_searchArray[ParameterType.SEARCH_MONTH_POS] = true;
	}

	/**
	 * Sets boolean value to {@code true} to signal that the user has searched
	 * for a day of month value.
	 */
	public void setDayOfMonthSearch() {
		_searchArray[ParameterType.SEARCH_DAY_POS] = true;
	}

	/**
	 * Sets boolean value to {@code true} to signal that the user has searched
	 * for a weekday value.
	 */
	public void setDayOfWeekSearch() {
		_searchArray[ParameterType.SEARCH_WEEKDAY_POS] = true;
	}

	/**
	 * Sets boolean value to {@code true} to signal that the user has searched
	 * for an hour value.
	 */
	public void setHourSearch() {
		_searchArray[ParameterType.SEARCH_HOUR_POS] = true;
	}

	/**
	 * Returns the OperationType that corresponds to the specified keyword
	 * string.
	 * 
	 * @param keyword
	 *            String for user specified operation command keyword.
	 * @return Corresponding OperationType for the specified keyword. Return an
	 *         invalid OperationType if specified keyword does not map to any
	 *         operation.
	 */
	public OperationType getOperationType(String keyword) {
		if (_cmdHash.containsKey(keyword)) {
			return _cmdHash.get(keyword);
		} else {
			return OperationType.INVALID;
		}

	}

	/**
	 * Returns the OperationType that is stored in CommandData that may have be
	 * set previously
	 * 
	 * @return OperationType that is stored in Command Data. Returns
	 *         {@code null} if no OperationType was set.
	 */
	public OperationType getUserOp() {
		return _userOp;
	}

	/**
	 * Hidden constructor for CommandData so that no new instance of CommandData can be made externally. 
	 * 
	 * Initialise command string hashtable by adding all recognised command
	 * strings as keys to respective OperationType.
	 *
	 */
	private CommandData() {
		initOpHash();

		for (int i = 0; i < _searchArray.length; i++) {
			_searchArray[i] = false;
		}

	}

	/**
	 * Adds all supported operation keyword into HashMap with the corresponding
	 * OperationType
	 */
	private void initOpHash() {
		// Adding support for all supported commands
		_cmdHash.put("display", OperationType.DISPLAY);
		_cmdHash.put("show", OperationType.DISPLAY);
		_cmdHash.put("add", OperationType.ADD);
		_cmdHash.put("a", OperationType.ADD);
		_cmdHash.put("put", OperationType.ADD);
		_cmdHash.put("p", OperationType.ADD);
		_cmdHash.put("modify", OperationType.MODIFY);
		_cmdHash.put("m", OperationType.MODIFY);
		_cmdHash.put("change", OperationType.MODIFY);
		_cmdHash.put("update", OperationType.MODIFY);
		_cmdHash.put("delete", OperationType.DELETE);
		_cmdHash.put("remove", OperationType.DELETE);
		_cmdHash.put("done", OperationType.DONE);
		_cmdHash.put("finish", OperationType.DONE);
		_cmdHash.put("clear", OperationType.CLEAR);
		_cmdHash.put("exit", OperationType.EXIT);
		_cmdHash.put("quit", OperationType.EXIT);
		_cmdHash.put("undo", OperationType.UNDO);
		_cmdHash.put("u", OperationType.UNDO);
		_cmdHash.put("search", OperationType.SEARCH);
		_cmdHash.put("s", OperationType.SEARCH);
		_cmdHash.put("find", OperationType.SEARCH);
		_paramArray = new String[ParameterType.MAX_SIZE];
		_searchArray = new boolean[ParameterType.SEARCH_MAX_SIZE];
	}

	public void setFileLocation(String filePathString) {
		_paramArray[ParameterType.NEW_FILELOCATION_POS] = filePathString;

	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\data\CommandData.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\tokeniser\Tokeniser.java
	 */


package com.nexus.simplify.parser.tokeniser;

/**
 * A tokeniser that splits a string into substrings that are seperated by
 * whitespaces.
 *
 */
public class Tokeniser {

	private static final String REGEX_WHITESPACE_ONCE_OR_MORE = "\\s+";

	/**
	 * Lexical analyser which takes in a string and produces a list of tokens. A
	 * token in Simplify is a combination of character sequences seperated by
	 * one whitespace character
	 * 
	 * @param userInput
	 *            Input string from user.
	 * @return An array of string tokens.
	 */
	public String[] tokenise(String userInput) {
		String[] stringArray = userInput.split(REGEX_WHITESPACE_ONCE_OR_MORE);
		return stringArray;
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\parser\tokeniser\Tokeniser.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\AbstractIntegrationTest.java
	 */


package com.nexus.simplify.test;

import static org.junit.Assert.*;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

import org.junit.Assert;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;
import com.nexus.simplify.MainApp;
import com.nexus.simplify.database.api.Database;
import com.nexus.simplify.database.core.LogicRequest;
import com.nexus.simplify.logic.api.Logic;
import com.nexus.simplify.logic.usercommand.UserCommand;
import com.nexus.simplify.parser.data.CommandData;

public abstract class AbstractIntegrationTest {
	private static MainApp _main;
	protected static Logic _logic;
	protected static Database _db;
	protected static LogicRequest _logicRequest;
	protected static UserCommand parsedCommand;
	protected static Parser _natty;

	public static void initMainApp() {
		try {
			_main = new MainApp();
			_logic = _main.getLogic();
			_db = MainApp.getDatabase();
			_logicRequest = _db.getLogicRequest();
			_natty = new Parser();

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Parses the given value into a collection of dates
	 * 
	 * @param value
	 * @return
	 */
	protected List<Date> parseCollection(String value) {
		List<DateGroup> dateGroup = _natty.parse(value);
		List<Date> dates = dateGroup.get(0).getDates();
		return dates;
	}

	/**
	 * Parses the given value, asserting that one and only one date is produced.
	 * 
	 * @param value
	 * @return
	 */
	protected Date parseSingleDate(String value) {
		if (value == null) {
			return null;
		}
		List<Date> dates = parseCollection(value);
		Assert.assertEquals(1, dates.size());
		return dates.get(0);
	}

	/**
	 * Asserts that the given user input is what Parser receives.
	 * 
	 * @param expected
	 * @throws Exception 
	 */
	protected void validateParserInput(String userInput) throws Exception {
		_logic.getParser().parseInput(userInput);
		String actual = _logic.getParser().getGivenInput();
		assertEquals(userInput, actual);
	}

	/**
	 * validates the input of parser and then proceed with parsing a single user input 
	 * 
	 * @param userInput
	 * @return
	 */
	protected UserCommand parseSingleInput(String userInput) {
		try {
			validateParserInput(userInput);
			parsedCommand = _logic.getParsedCommand(userInput);			

		} catch (Exception e) {
			e.printStackTrace();
		}
		return parsedCommand;
	}

	/**
	 * Converts a natural datetime string into Java date string representation
	 * @param dateTime
	 * @return
	 */
	protected String naturalToJavaString(String dateTime) {
		Date java = null;
		java = parseSingleDate(dateTime); 
		if (java == null) {
			return null;
		} else {
			return java.toString();
		}
	}


	/**
	 * Asserts that the given user input parses into the given index, name, start time, end time
	 * 
	 * @param userInput
	 * @param index
	 * @param name
	 * @param startTime
	 * @param endTime
	 * @param workload
	 * @param fileLocation
	 */
	protected UserCommand validateParsedCommand(String userInput, String operation, String index, String name, 
			String startTime, String endTime, Object workload, String fileLocation) {
		startTime = naturalToJavaString(startTime);
		endTime = naturalToJavaString(endTime);
		parsedCommand = parseSingleInput(userInput);
		assertEquals(CommandData.getInstance().getOperationType(operation), parsedCommand.getOperationType());
		assertEquals(index, parsedCommand.getIndex());
		assertEquals(name, parsedCommand.getName());
		assertEquals(removeSeconds(startTime), removeSeconds(parsedCommand.getStartTime()));
		assertEquals(removeSeconds(endTime), removeSeconds(parsedCommand.getEndTime()));
		assertEquals(workloadToString(workload), parsedCommand.getWorkload());
		assertEquals(fileLocation, parsedCommand.getFileLocation());
		return parsedCommand;
	}


	protected Date javaDateStringToDate(String javaDate) {
		String pattern = "E MMM dd hh:mm:ss zzz yyy";
		SimpleDateFormat df = new SimpleDateFormat(pattern);
		Date date = null;
		try {
			date = df.parse(javaDate);
		} catch (ParseException e) {
			e.printStackTrace();
		}
		return date;
	}

	protected Object indexStringToInt(String string) {
		if (string == null) {
			return null;
		} else {
			int index = Integer.parseInt(string);
			return index;
		}
	}

	protected String workloadToString(Object workload) {
		if (workload == null) {
			return null;
		} else {
			return Integer.toString((int)workload);
		}
	}

	protected int normaliseWorkload(Object workload) {
		if (workload == null) {
			return 0;
		} else {
			return Integer.parseInt((String)workload);
		}
	}

	protected void validateCallOnDatabase(String userInput, UserCommand userCommand) {
		try {
			_logic.executeCommand(userInput);
		} catch (Exception e) {
			e.printStackTrace();
		}
		assertEquals(userCommand.getOperationType(), _logicRequest.getOperationType());
		assertEquals(indexStringToInt(userCommand.getIndex()), _logicRequest.getIndex());
		assertEquals(userCommand.getName(), _logicRequest.getName());
		assertEquals(parseSingleDate(userCommand.getStartTime()), _logicRequest.getStartTime());
		assertEquals(parseSingleDate(userCommand.getEndTime()), _logicRequest.getEndTime());
		assertEquals(normaliseWorkload(userCommand.getWorkload()), _logicRequest.getWorkload());
		assertEquals(userCommand.getFileLocation(), _logicRequest.getFileLocation());
	}

	protected void testSingleInput(String userInput, String operation, String index, String name, String startTime, 
			String endTime, Object workload, String fileLocation) {
		UserCommand userCommand = validateParsedCommand(userInput, operation, index, name, startTime, endTime, workload, fileLocation);
		validateCallOnDatabase(userInput, userCommand);
	}
	
	// Mon Apr 11 12:54:27 SGT 2016
	private String removeSeconds(String DateTime) {
		if (DateTime == null) {
			return null;
		}
		assert(DateTime.length() == 23);
		String left = DateTime.substring(0, 17);
		String right = DateTime.substring(19);
		return left+right;
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\AbstractIntegrationTest.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\AllTests.java
	 */


package com.nexus.simplify.test;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;

import com.nexus.simplify.test.database.DatabaseTest;
import com.nexus.simplify.test.logic.TestAdd;
import com.nexus.simplify.test.logic.TestDelete;
import com.nexus.simplify.test.logic.TestDisplay;
import com.nexus.simplify.test.logic.TestDone;
import com.nexus.simplify.test.logic.TestModify;
import com.nexus.simplify.test.parser.ParserTest;
import com.nexus.simplify.test.ui.CommandHistoryTest;

@RunWith(Suite.class)
@SuiteClasses({
    
	MultipleIntegrationsTest.class,
    
	// Parser Unit Tests
	ParserTest.class,
	
	// Logic Unit Tests
	TestAdd.class,
	TestDelete.class,
	TestDisplay.class,
	TestDone.class,
	TestModify.class,
    
	// Database Unit Tests
	DatabaseTest.class,
	
	// UI Unit Test
	CommandHistoryTest.class
})

public class AllTests {}
	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\AllTests.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\MultipleIntegrationsTest.java
	 */


package com.nexus.simplify.test;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

/**
 * System Testing for Add command
 */
public class MultipleIntegrationsTest extends AbstractIntegrationTest {

	@BeforeClass
	public static void oneTime() {
		initMainApp();
	}

	@Before
	public void resetLogicRequest(){
		_logicRequest.reset();
	}

	@Test
	public void testTimedTask() {
		testSingleInput("add drink coffee 8pm - 9pm", "add", null, "drink coffee", 
				"8pm", "9pm", null, null);
		testSingleInput("a meeting w5 tomorrow 2pm to 4pm", "add",  null, "meeting", 
				"tomorrow 2pm", "tomorrow 4pm", 5, null);
		testSingleInput("add dinner with tom tomorrow 1400 - 1600", "add",  null, "dinner with tom", 
				"tomorrow 1400", "tomorrow 1600", null, null);
		testSingleInput("add camping tomorrow 12pm to 8 pm 2 weeks from now w1", "add",  null, "camping",
				"tomorrow 12pm", "8pm 2 weeks from now", 1, null);

	}

	@Test
	public void testDeadlineTask() {
		testSingleInput("add V0.3 Demo tomorrow 3pm", "add",  null, "V0.3 Demo",
				"tomorrow 3pm", "tomorrow 3pm", null, null);
		testSingleInput("a V0.3 Demo 1 Apr 3pm w4", "add",  null, "V0.3 Demo",
				"1 Apr 3pm", "1 Apr 3pm", 4, null);
		testSingleInput("add V0.3 Demo w3 next week", "add",  null, "V0.3 Demo",
				"next week", "next week", 3, null);
		testSingleInput("add V0.3 Demo w5 5 days from now", "add",  null, "V0.3 Demo",
				"5 days from now", "5 days from now", 5, null);
	}

	@Test
	public void testGenericTask() {
		testSingleInput("add train for ippt w5", "add",  null, "train for ippt",
				null, null, 5, null);
		testSingleInput("a read", "add",  null, "read",
				null, null, null, null);
		testSingleInput("add learn web dev w5", "add",  null, "learn web dev",
				null, null, 5, null);
		testSingleInput("add catch up on lectures", "add",  null, "catch up on lectures",
				null, null, null, null);
	}

}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\MultipleIntegrationsTest.java





	/**
	 * origin: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\parser\ParserTest.java
	 */


package com.nexus.simplify.test.parser;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import com.nexus.simplify.test.AbstractIntegrationTest;

import edu.emory.mathcs.backport.java.util.Arrays;

/**
 * Unit Test class for Parser component. 
 * 
 * Actual input command string is given to Parser.parse method. 
 * DateTime input used are supported by natty at http://natty.joestelmach.com/try.jsp
 * Unsupported DateTime strings will be taken to be name of the task, thus there will be error during comparison 
 * if the intended DateTime string is not recognised as a DateTime
 * Results from parsing are stored in CommandData and the values are taken for comparison
 * 
 * Expected output are manually specified, individually.
 * Expected DateTime output is the DateTime that natty library parses from the given string 
 * that implies DateTime Element
 * 
 *
 */
public class ParserTest extends AbstractIntegrationTest {
	final String DISPLAY = "display";
	final String ADD = "add";
	final String MODIFY = "modify";
	final String DELETE = "delete";
	final String CLEAR = "clear";
	final String DONE = "done";
	final String UNDO = "undo";
	final String SEARCH = "search";
	final String TEST_NAME = "Parser Unit Testing";

	@BeforeClass
	public static void oneTime() {
		initMainApp();
	}

	@Before
	public void resetLogicRequest(){
		_logicRequest.reset();
	}

	@Test
	public void testDisplay() {
		validateParsedCommand("display", DISPLAY, null, null, null, null, null, null);
		validateParsedCommand("display week", DISPLAY, "week", null, null, null, null, null);
		validateParsedCommand("display deadline", DISPLAY, "deadline", null, null, null, null, null);
		validateParsedCommand("display default", DISPLAY, "default", null, null, null, null, null);

		// invalid display parameters
		validateParsedCommand("display -1", DISPLAY, "-1", null, null, null, null, null);
		validateParsedCommand("display .", DISPLAY, ".", null, null, null, null, null);
		validateParsedCommand("display asdasd9808", DISPLAY, "asdasd9808", null, null, null, null, null);
	}

	@Test
	public void testAddName() {
		// Empty string boundary case for no name partition 
		validateParsedCommand("add", ADD, null, null, null, null, null, null);

		// " " string boundary case for whitespace parameter partition 
		validateParsedCommand("add  ", ADD, null, null, null, null, null, null);

		// "." string boundary case for valid name partition
		validateParsedCommand("add .", ADD, null, ".", null, null, null, null);

		// very long string boundary case for valid name partition
		char[] manyChars = new char[5000];
		Arrays.fill(manyChars, "a".charAt(0));
		String longString = new String(manyChars);
		validateParsedCommand("add " + longString, ADD, null, longString, null, null, null, null);

		// trailing whitespace
		validateParsedCommand("a trailing ", ADD, null, "trailing", null, null, null, null);
		validateParsedCommand("add trailing  ", ADD, null, "trailing", null, null, null, null);

		// leading whitespace
		validateParsedCommand("add  leading ", ADD, null, "leading", null, null, null, null);
		validateParsedCommand("add   leading  ", ADD, null, "leading", null, null, null, null);

		// cases to stress-test Parser  
		// words with a mix of digits
		validateParsedCommand("add CS2100", ADD, null, "CS2100", null, null, null, null);
		// name contains word that contains workload param
		validateParsedCommand("add w1w1", ADD, null, "w1w1", null, null, null, null);
	}

	@Test
	public void testAddDeadline() {
		// Natty supported common English phrases used to denote date
		validateAddSingleDateTime("tomorrow");
		validateAddSingleDateTime("day after tomorrow");
		validateAddSingleDateTime("week after tomorrow");

		validateAddSingleDateTime("next day");
		validateAddSingleDateTime("next Monday");
		validateAddSingleDateTime("next week");
		validateAddSingleDateTime("next month");
		validateAddSingleDateTime("next year");
		validateAddSingleDateTime("next spring");
		validateAddSingleDateTime("next summer");
		validateAddSingleDateTime("next autumn");
		validateAddSingleDateTime("next winter");

		validateAddSingleDateTime("upcoming day");
		validateAddSingleDateTime("upcoming Sunday");
		validateAddSingleDateTime("upcoming week");
		validateAddSingleDateTime("upcoming month");
		validateAddSingleDateTime("upcoming year");
		validateAddSingleDateTime("upcoming spring");
		validateAddSingleDateTime("upcoming summer");
		validateAddSingleDateTime("upcoming autumn");
		validateAddSingleDateTime("upcoming winter");

		// Specifying specific date
		validateAddSingleDateTime("15 April");
		validateAddSingleDateTime("15 Apr");
		validateAddSingleDateTime("15th Apr");
		validateAddSingleDateTime("15 Apr 2016");
		validateAddSingleDateTime("15 April 2016");
		validateAddSingleDateTime("15/4");
		validateAddSingleDateTime("15/4");
		validateAddSingleDateTime("15/4/2015");
		validateAddSingleDateTime("15 Apr");

		// Specifying Time
		validateAddSingleDateTime("4pm");
		validateAddSingleDateTime("4 pm");
		validateAddSingleDateTime("1600");
		validateAddSingleDateTime("1600h");
		validateAddSingleDateTime("1600 hour");

		//Specifying Date and Time
		validateAddSingleDateTime("tomorrow 4pm");
		validateAddSingleDateTime("next day 1600 pm");
		validateAddSingleDateTime("next Monday 1600");
		validateAddSingleDateTime("next year 1600h");
		validateAddSingleDateTime("next spring 1600 hour");
		validateAddSingleDateTime("week after tomorrow 4pm");
		validateAddSingleDateTime("week after tomorrow 8am");
		validateAddSingleDateTime("week after 17 April 8 am");
		validateAddSingleDateTime("month after 17 April 8");
		validateAddSingleDateTime("day after tomorrow 0800");		

		// boundary case for invalid deadline
		validateParsedCommand("add no deadline 20 apri", ADD, null, "no deadline apri", "20", "20", null, null);
	}

	@Test
	public void testAddGenericWorkload() {
		// boundary case for valid workload
		validateAddNameWorkLoad("LOWEST WORKLOAD", 1);
		validateAddNameWorkLoad("HIGHEST WORKLOAD", 5);

		// boundary case for invalid workload
		validateParsedCommand("add boundary case w0", ADD, null, "boundary case w0", null, null, null, null);
		validateParsedCommand("add boundary case w6", ADD, null, "boundary case w6", null, null, null, null);

		// name contains a word which contains workload param as subsequence
		validateAddNameWorkLoad("w1a", 5);
	}

	@Test
	public void testAddDeadlineWorkload() {
		validateAddNameSingleDateTimeWorkload(TEST_NAME, "tomorrow", 1);

		// boundary case for invalid workload
		validateParsedCommand("add boundary case w0 20 oct", ADD, null, "boundary case w0", "20 oct", "20 oct", null, null);

		// boundary case for invalid name
		validateParsedCommand("add w5 20/04", ADD, null, null, "20/04", "20/04", 5, null);

		// boundary case for invalid deadline
		validateParsedCommand("add no deadline w5 apri", ADD, null, "no deadline apri", null, null, 5, null);

	}

	@Test
	public void testAddTimedWorkload() {
		validateAddNameTimedWorkload("oneword", "8 to 5 pm 19 apr", "8pm 19 apr", "5 pm 19 apr", 5);
		validateAddNameTimedWorkload("two words!", "8am to 5pm 19 apr", "8am 19 apr", "5pm 19 apr", 4);
		validateAddNameTimedWorkload("do parser unit testing", "8am to 2pm", "8am", "2pm", 3);
		validateAddNameTimedWorkload("prepare for CS2101 oral discussion", "1700 to 1900 14 apr", "1700 14 apr", "1900 14 apr", 2);
	}

	@Test
	public void testModify() {
		validateParsedCommand("modify 1 new name!", MODIFY, "1", "new name!", null, null, null, null);
		validateParsedCommand("modify 2 new name!"	, MODIFY, "2", "new name!", null, null, null, null);

		// negative index is invalid and is taken as part of the name
		validateParsedCommand("modify -1 new name!"	, MODIFY, null, "-1 new name!", null, null, null, null);
	}

	@Test
	public void testDelete() {
		validateParsedCommand("delete 1", DELETE, "1", null, null, null, null, null);
		validateParsedCommand("delete 100 workload", DELETE, "100", "workload", null, null, null, null);

		// negative index is invalid and is taken as part of the parameter
		validateParsedCommand("delete -1 deadline", DELETE, null, "-1 deadline", null, null, null, null);
	}

	@Test
	public void testClear() {
		validateParsedCommand("clear", CLEAR, null, null, null, null, null, null);
	}

	@Test
	public void testDone() {
		validateParsedCommand("done", DONE, null, null, null, null, null, null);
	}

	@Test
	public void testUndo() {
		validateParsedCommand("undo", UNDO, null, null, null, null, null, null);
		validateParsedCommand("u", UNDO, null, null, null, null, null, null);
	}

	@Test
	public void testSearch() {
		// search for name
		validateParsedCommand("search looking for a name", SEARCH, null, "looking for a name", null, null, null, null);

		// search directly specified HOURS, DAY OF WEEK, DAY OF MONTH, MONTH or YEAR
		// excludes "search tomorrow"
		validateParsedCommand("search fri", SEARCH, null, null, "fri", "fri", null, null);
		validateParsedCommand("search friday", SEARCH, null, null, "fri", "fri", null, null);
		validateParsedCommand("search apr", SEARCH, null, null, "apr", "apr", null, null);
		validateParsedCommand("search 0930", SEARCH, null, null, "0930", "0930", null, null);
		validateParsedCommand("search year 2020", SEARCH, null, null, "1 Jan 2020", "1 Jan 2020", null, null);
		validateParsedCommand("search 0000 year", SEARCH, null, null, "1 Jan 0000", "1 Jan 0000", null, null);
		validateParsedCommand("search -1 year", SEARCH, null, "-1 year", null, null, null, null);
		validateParsedCommand("search year -1", SEARCH, null, "year -1", null, null, null, null);

		// search for workload
		validateParsedCommand("search w1", SEARCH, null, null, null, null, 1, null);
		validateParsedCommand("search w5", SEARCH, null, null, null, null, 5, null);
		validateParsedCommand("search w0", SEARCH, null, "w0", null, null, null, null);
		validateParsedCommand("search w6", SEARCH, null, "w6", null, null, null, null);
	}

	@Test
	public void testInterleavedParam() {
		// the DateTime and workload parameters can be blended into task names.
		// for DateTime phrases, the words cannot be spread out across the names. they must be present together as a subsetence
		validateParsedCommand("add do tomorrow CS3230 w3 tutorial", ADD, null, "do CS3230 tutorial", "tomorrow", "tomorrow", 3, null);
		validateParsedCommand("add attend w4 meeting tomorrow 4pm to 5pm at office", ADD, null, "attend meeting at office", "tomorrow 4pm", "tomorrow 5pm", 4, null);
		validateParsedCommand("add start 9am to 10pm next week revising for finals w5", ADD, null, "start revising for finals", "next week 9am", "next week 10pm", 5, null);
	}

	@Test
	public void testDoubleQuotesEscape() {
		// using double quotes as an escape for DateTime
		validateParsedCommand("add watch \"the day after tomorrow\" day after tomorrow", ADD, null, "watch the day after tomorrow", "day after tomorrow", "day after tomorrow", null, null);
		validateParsedCommand("add \"April Fools\" w2 12am 1 April", ADD, null, "April Fools", "12am 1 April", "12am 1 April", 2, null);
		validateParsedCommand("add w5 \"Chrismas\" Dinner  1800h to 1900h Christmas", ADD, null, "Chrismas Dinner", "1800h Christmas", "1900h Christmas", 5, null);

		// using two double quotes to record single double quotes
		validateParsedCommand("add Remember the date: \"\"13 April\"\" 13 April", ADD, null, "Remember the date: \"13 April\"", "13 April", "13 April", null, null);
		
		// using double quotes as an escape for workload
		validateParsedCommand("add \"w1\" w1", ADD, null, "w1", null, null, 1, null);
		validateParsedCommand("add \"w0\" w0", ADD, null, "w0 w0", null, null, null, null);
		
		// search
		validateParsedCommand("search looking for a \"day\"", SEARCH, null, "looking for a day", null, null, null, null);
		validateParsedCommand("search looking for \"\"a few quoted words\"\"", SEARCH, null, "looking for \"a few quoted words\"", null, null, null, null);
	}

	private void validateAddSingleDateTime(String dt) {
		validateParsedCommand(ADD + " " + TEST_NAME + " " + dt, ADD, null, TEST_NAME, dt, dt, null, null);
		validateParsedCommand(ADD  + " "+ dt + " " + TEST_NAME, ADD, null, TEST_NAME, dt, dt, null, null);
	}

	private void validateAddNameWorkLoad(String name, int workload) {
		assert(workload > 0 && workload < 6);
		String workloadString = "w"+workload;
		validateParsedCommand(ADD + " " + name + " " + workloadString, ADD, null, name, null, null, workload, null);
		validateParsedCommand(ADD + " " + workloadString + " " + name, ADD, null, name, null, null, workload, null);
	}

	private void validateAddNameSingleDateTimeWorkload(String name, String dateTime, int workload) {
		String workloadString = "w"+workload;
		validateParsedCommand(ADD + " " + name + " " + dateTime + " " + workloadString, ADD, null, name, dateTime, dateTime, workload, null);
		validateParsedCommand(ADD + " " + name + " " + workloadString + " " + dateTime, ADD, null, name, dateTime, dateTime, workload, null);
		validateParsedCommand(ADD + " " + workloadString + " " + name + " " + dateTime, ADD, null, name, dateTime, dateTime, workload, null);
		validateParsedCommand(ADD + " " + workloadString + " " + dateTime + " " + name, ADD, null, name, dateTime, dateTime, workload, null);
		validateParsedCommand(ADD + " " + dateTime + " " + name + " " + workloadString, ADD, null, name, dateTime, dateTime, workload, null);
		validateParsedCommand(ADD + " " + dateTime + " " + workloadString + " " + name, ADD, null, name, dateTime, dateTime, workload, null);
	}

	private void validateAddNameTimedWorkload(String name, String range, String startTime, String endTime, int workload) {
		String workloadString = "w"+workload;
		validateParsedCommand(ADD + " " + name + " " + range + " " + workloadString, ADD, null, name, startTime, endTime, workload, null);
		validateParsedCommand(ADD + " " + name + " " + workloadString + " " + range, ADD, null, name, startTime, endTime, workload, null);
		validateParsedCommand(ADD + " " + workloadString + " " + name + " " + range, ADD, null, name, startTime, endTime, workload, null);
		validateParsedCommand(ADD + " " + workloadString + " " + range + " " + name, ADD, null, name, startTime, endTime, workload, null);
		validateParsedCommand(ADD + " " + range + " " + name + " " + workloadString, ADD, null, name, startTime, endTime, workload, null);
		validateParsedCommand(ADD + " " + range + " " + workloadString + " " + name, ADD, null, name, startTime, endTime, workload, null);
	}
}

	// End of segment: C:\Users\Davis\workspace\CS2103-NEXUS\src\com\nexus\simplify\test\parser\ParserTest.java





